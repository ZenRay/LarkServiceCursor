<?xml version="1.0" encoding="utf-8"?><testsuites name="pytest tests"><testsuite name="pytest" errors="15" failures="0" skipped="0" tests="144" time="25.935" timestamp="2026-01-15T11:47:48.132339+00:00" hostname="runnervmi13qx"><testcase classname="tests.integration.test_credential_pool.TestCredentialPoolIntegration" name="test_lazy_loading" time="0.105"><error message="failed on setup with &quot;lark_service.core.exceptions.StorageError: Failed to initialize TokenStorageService: (psycopg2.OperationalError) connection to server at &quot;localhost&quot; (::1), port 5432 failed: Connection refused&#10;&#09;Is the server running on that host and accepting TCP/IP connections?&#10;connection to server at &quot;localhost&quot; (127.0.0.1), port 5432 failed: Connection refused&#10;&#09;Is the server running on that host and accepting TCP/IP connections?&#10;&#10;(Background on this error at: https://sqlalche.me/e/20/e3q8)&quot;">self = &lt;sqlalchemy.engine.base.Connection object at 0x7fa855714e60&gt;
engine = Engine(postgresql://lark:***@localhost:5432/lark_service)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
&gt;               self._dbapi_connection = engine.raw_connection()
                                         ^^^^^^^^^^^^^^^^^^^^^^^

/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lark_service user=lark password=lark_password_123 port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lark_service', 'host': 'localhost', 'password': 'lark_password_123', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
&gt;       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

self = &lt;lark_service.core.storage.postgres_storage.TokenStorageService object at 0x7fa8562aa330&gt;
postgres_url = 'postgresql://lark:lark_password_123@localhost:5432/lark_service'
pool_size = 10, max_overflow = 20, pool_timeout = 30

    def __init__(
        self,
        postgres_url: str,
        pool_size: int = 10,
        max_overflow: int = 20,
        pool_timeout: int = 30,
    ) -&gt; None:
        """Initialize TokenStorageService.
    
        Args:
            postgres_url: PostgreSQL connection URL
            pool_size: Number of connections to maintain in pool
            max_overflow: Maximum overflow connections
            pool_timeout: Timeout for getting connection from pool (seconds)
    
        Raises:
            StorageError: If database initialization fails
    
        Example:
            &gt;&gt;&gt; service = TokenStorageService(
            ...     "postgresql://user:pass@localhost/db",
            ...     pool_size=10,
            ... )
        """
        self.postgres_url = postgres_url
    
        try:
            # Create engine with connection pool
            self.engine = create_engine(
                postgres_url,
                poolclass=QueuePool,
                pool_size=pool_size,
                max_overflow=max_overflow,
                pool_timeout=pool_timeout,
                pool_pre_ping=True,  # Verify connections before use
                echo=False,
            )
    
            # Create session factory
            self.session_factory = sessionmaker(bind=self.engine)
    
            # Create tables (idempotent)
&gt;           Base.metadata.create_all(self.engine)

src/lark_service/core/storage/postgres_storage.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5928: in create_all
    bind._run_ddl_visitor(
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3259: in _run_ddl_visitor
    with self.begin() as conn:
         ^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3249: in begin
    with self.connect() as conn:
         ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3285: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:145: in __init__
    Connection._handle_dbapi_exception_noconnection(
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2448: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lark_service user=lark password=lark_password_123 port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lark_service', 'host': 'localhost', 'password': 'lark_password_123', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
&gt;       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

test_config = Config(postgres_host='localhost', postgres_port=5432, postgres_db='lark_service', postgres_user='lark', postgres_passw...t_lazy_loading0/test_config.db'), log_level='INFO', max_retries=3, retry_backoff_base=1.0, token_refresh_threshold=0.1)

    @pytest.fixture
    def token_storage(test_config: Config) -&gt; TokenStorageService:
        """Create TokenStorageService for tests."""
&gt;       service = TokenStorageService(test_config.get_postgres_url())
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/integration/test_credential_pool.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;lark_service.core.storage.postgres_storage.TokenStorageService object at 0x7fa8562aa330&gt;
postgres_url = 'postgresql://lark:lark_password_123@localhost:5432/lark_service'
pool_size = 10, max_overflow = 20, pool_timeout = 30

    def __init__(
        self,
        postgres_url: str,
        pool_size: int = 10,
        max_overflow: int = 20,
        pool_timeout: int = 30,
    ) -&gt; None:
        """Initialize TokenStorageService.
    
        Args:
            postgres_url: PostgreSQL connection URL
            pool_size: Number of connections to maintain in pool
            max_overflow: Maximum overflow connections
            pool_timeout: Timeout for getting connection from pool (seconds)
    
        Raises:
            StorageError: If database initialization fails
    
        Example:
            &gt;&gt;&gt; service = TokenStorageService(
            ...     "postgresql://user:pass@localhost/db",
            ...     pool_size=10,
            ... )
        """
        self.postgres_url = postgres_url
    
        try:
            # Create engine with connection pool
            self.engine = create_engine(
                postgres_url,
                poolclass=QueuePool,
                pool_size=pool_size,
                max_overflow=max_overflow,
                pool_timeout=pool_timeout,
                pool_pre_ping=True,  # Verify connections before use
                echo=False,
            )
    
            # Create session factory
            self.session_factory = sessionmaker(bind=self.engine)
    
            # Create tables (idempotent)
            Base.metadata.create_all(self.engine)
    
            logger.info(
                "TokenStorageService initialized",
                extra={
                    "pool_size": pool_size,
                    "max_overflow": max_overflow,
                },
            )
    
        except Exception as e:
&gt;           raise StorageError(
                f"Failed to initialize TokenStorageService: {e}",
                details={"error": str(e)},
            ) from e
E           lark_service.core.exceptions.StorageError: Failed to initialize TokenStorageService: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E           	Is the server running on that host and accepting TCP/IP connections?
E           connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E           	Is the server running on that host and accepting TCP/IP connections?
E           
E           (Background on this error at: https://sqlalche.me/e/20/e3q8)

src/lark_service/core/storage/postgres_storage.py:84: StorageError</error></testcase><testcase classname="tests.integration.test_credential_pool.TestCredentialPoolIntegration" name="test_token_refresh_when_expired" time="0.007"><error message="failed on setup with &quot;lark_service.core.exceptions.StorageError: Failed to initialize TokenStorageService: (psycopg2.OperationalError) connection to server at &quot;localhost&quot; (::1), port 5432 failed: Connection refused&#10;&#09;Is the server running on that host and accepting TCP/IP connections?&#10;connection to server at &quot;localhost&quot; (127.0.0.1), port 5432 failed: Connection refused&#10;&#09;Is the server running on that host and accepting TCP/IP connections?&#10;&#10;(Background on this error at: https://sqlalche.me/e/20/e3q8)&quot;">self = &lt;sqlalchemy.engine.base.Connection object at 0x7fa854bf8710&gt;
engine = Engine(postgresql://lark:***@localhost:5432/lark_service)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
&gt;               self._dbapi_connection = engine.raw_connection()
                                         ^^^^^^^^^^^^^^^^^^^^^^^

/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lark_service user=lark password=lark_password_123 port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lark_service', 'host': 'localhost', 'password': 'lark_password_123', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
&gt;       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

self = &lt;lark_service.core.storage.postgres_storage.TokenStorageService object at 0x7fa85573e660&gt;
postgres_url = 'postgresql://lark:lark_password_123@localhost:5432/lark_service'
pool_size = 10, max_overflow = 20, pool_timeout = 30

    def __init__(
        self,
        postgres_url: str,
        pool_size: int = 10,
        max_overflow: int = 20,
        pool_timeout: int = 30,
    ) -&gt; None:
        """Initialize TokenStorageService.
    
        Args:
            postgres_url: PostgreSQL connection URL
            pool_size: Number of connections to maintain in pool
            max_overflow: Maximum overflow connections
            pool_timeout: Timeout for getting connection from pool (seconds)
    
        Raises:
            StorageError: If database initialization fails
    
        Example:
            &gt;&gt;&gt; service = TokenStorageService(
            ...     "postgresql://user:pass@localhost/db",
            ...     pool_size=10,
            ... )
        """
        self.postgres_url = postgres_url
    
        try:
            # Create engine with connection pool
            self.engine = create_engine(
                postgres_url,
                poolclass=QueuePool,
                pool_size=pool_size,
                max_overflow=max_overflow,
                pool_timeout=pool_timeout,
                pool_pre_ping=True,  # Verify connections before use
                echo=False,
            )
    
            # Create session factory
            self.session_factory = sessionmaker(bind=self.engine)
    
            # Create tables (idempotent)
&gt;           Base.metadata.create_all(self.engine)

src/lark_service/core/storage/postgres_storage.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5928: in create_all
    bind._run_ddl_visitor(
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3259: in _run_ddl_visitor
    with self.begin() as conn:
         ^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3249: in begin
    with self.connect() as conn:
         ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3285: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:145: in __init__
    Connection._handle_dbapi_exception_noconnection(
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2448: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lark_service user=lark password=lark_password_123 port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lark_service', 'host': 'localhost', 'password': 'lark_password_123', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
&gt;       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

test_config = Config(postgres_host='localhost', postgres_port=5432, postgres_db='lark_service', postgres_user='lark', postgres_passw...sh_when_expire0/test_config.db'), log_level='INFO', max_retries=3, retry_backoff_base=1.0, token_refresh_threshold=0.1)

    @pytest.fixture
    def token_storage(test_config: Config) -&gt; TokenStorageService:
        """Create TokenStorageService for tests."""
&gt;       service = TokenStorageService(test_config.get_postgres_url())
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/integration/test_credential_pool.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;lark_service.core.storage.postgres_storage.TokenStorageService object at 0x7fa85573e660&gt;
postgres_url = 'postgresql://lark:lark_password_123@localhost:5432/lark_service'
pool_size = 10, max_overflow = 20, pool_timeout = 30

    def __init__(
        self,
        postgres_url: str,
        pool_size: int = 10,
        max_overflow: int = 20,
        pool_timeout: int = 30,
    ) -&gt; None:
        """Initialize TokenStorageService.
    
        Args:
            postgres_url: PostgreSQL connection URL
            pool_size: Number of connections to maintain in pool
            max_overflow: Maximum overflow connections
            pool_timeout: Timeout for getting connection from pool (seconds)
    
        Raises:
            StorageError: If database initialization fails
    
        Example:
            &gt;&gt;&gt; service = TokenStorageService(
            ...     "postgresql://user:pass@localhost/db",
            ...     pool_size=10,
            ... )
        """
        self.postgres_url = postgres_url
    
        try:
            # Create engine with connection pool
            self.engine = create_engine(
                postgres_url,
                poolclass=QueuePool,
                pool_size=pool_size,
                max_overflow=max_overflow,
                pool_timeout=pool_timeout,
                pool_pre_ping=True,  # Verify connections before use
                echo=False,
            )
    
            # Create session factory
            self.session_factory = sessionmaker(bind=self.engine)
    
            # Create tables (idempotent)
            Base.metadata.create_all(self.engine)
    
            logger.info(
                "TokenStorageService initialized",
                extra={
                    "pool_size": pool_size,
                    "max_overflow": max_overflow,
                },
            )
    
        except Exception as e:
&gt;           raise StorageError(
                f"Failed to initialize TokenStorageService: {e}",
                details={"error": str(e)},
            ) from e
E           lark_service.core.exceptions.StorageError: Failed to initialize TokenStorageService: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E           	Is the server running on that host and accepting TCP/IP connections?
E           connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E           	Is the server running on that host and accepting TCP/IP connections?
E           
E           (Background on this error at: https://sqlalche.me/e/20/e3q8)

src/lark_service/core/storage/postgres_storage.py:84: StorageError</error></testcase><testcase classname="tests.integration.test_credential_pool.TestCredentialPoolIntegration" name="test_token_refresh_threshold" time="0.007"><error message="failed on setup with &quot;lark_service.core.exceptions.StorageError: Failed to initialize TokenStorageService: (psycopg2.OperationalError) connection to server at &quot;localhost&quot; (::1), port 5432 failed: Connection refused&#10;&#09;Is the server running on that host and accepting TCP/IP connections?&#10;connection to server at &quot;localhost&quot; (127.0.0.1), port 5432 failed: Connection refused&#10;&#09;Is the server running on that host and accepting TCP/IP connections?&#10;&#10;(Background on this error at: https://sqlalche.me/e/20/e3q8)&quot;">self = &lt;sqlalchemy.engine.base.Connection object at 0x7fa854bfba40&gt;
engine = Engine(postgresql://lark:***@localhost:5432/lark_service)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
&gt;               self._dbapi_connection = engine.raw_connection()
                                         ^^^^^^^^^^^^^^^^^^^^^^^

/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lark_service user=lark password=lark_password_123 port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lark_service', 'host': 'localhost', 'password': 'lark_password_123', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
&gt;       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

self = &lt;lark_service.core.storage.postgres_storage.TokenStorageService object at 0x7fa854bfbfb0&gt;
postgres_url = 'postgresql://lark:lark_password_123@localhost:5432/lark_service'
pool_size = 10, max_overflow = 20, pool_timeout = 30

    def __init__(
        self,
        postgres_url: str,
        pool_size: int = 10,
        max_overflow: int = 20,
        pool_timeout: int = 30,
    ) -&gt; None:
        """Initialize TokenStorageService.
    
        Args:
            postgres_url: PostgreSQL connection URL
            pool_size: Number of connections to maintain in pool
            max_overflow: Maximum overflow connections
            pool_timeout: Timeout for getting connection from pool (seconds)
    
        Raises:
            StorageError: If database initialization fails
    
        Example:
            &gt;&gt;&gt; service = TokenStorageService(
            ...     "postgresql://user:pass@localhost/db",
            ...     pool_size=10,
            ... )
        """
        self.postgres_url = postgres_url
    
        try:
            # Create engine with connection pool
            self.engine = create_engine(
                postgres_url,
                poolclass=QueuePool,
                pool_size=pool_size,
                max_overflow=max_overflow,
                pool_timeout=pool_timeout,
                pool_pre_ping=True,  # Verify connections before use
                echo=False,
            )
    
            # Create session factory
            self.session_factory = sessionmaker(bind=self.engine)
    
            # Create tables (idempotent)
&gt;           Base.metadata.create_all(self.engine)

src/lark_service/core/storage/postgres_storage.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5928: in create_all
    bind._run_ddl_visitor(
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3259: in _run_ddl_visitor
    with self.begin() as conn:
         ^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3249: in begin
    with self.connect() as conn:
         ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3285: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:145: in __init__
    Connection._handle_dbapi_exception_noconnection(
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2448: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lark_service user=lark password=lark_password_123 port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lark_service', 'host': 'localhost', 'password': 'lark_password_123', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
&gt;       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

test_config = Config(postgres_host='localhost', postgres_port=5432, postgres_db='lark_service', postgres_user='lark', postgres_passw...resh_threshold0/test_config.db'), log_level='INFO', max_retries=3, retry_backoff_base=1.0, token_refresh_threshold=0.1)

    @pytest.fixture
    def token_storage(test_config: Config) -&gt; TokenStorageService:
        """Create TokenStorageService for tests."""
&gt;       service = TokenStorageService(test_config.get_postgres_url())
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/integration/test_credential_pool.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;lark_service.core.storage.postgres_storage.TokenStorageService object at 0x7fa854bfbfb0&gt;
postgres_url = 'postgresql://lark:lark_password_123@localhost:5432/lark_service'
pool_size = 10, max_overflow = 20, pool_timeout = 30

    def __init__(
        self,
        postgres_url: str,
        pool_size: int = 10,
        max_overflow: int = 20,
        pool_timeout: int = 30,
    ) -&gt; None:
        """Initialize TokenStorageService.
    
        Args:
            postgres_url: PostgreSQL connection URL
            pool_size: Number of connections to maintain in pool
            max_overflow: Maximum overflow connections
            pool_timeout: Timeout for getting connection from pool (seconds)
    
        Raises:
            StorageError: If database initialization fails
    
        Example:
            &gt;&gt;&gt; service = TokenStorageService(
            ...     "postgresql://user:pass@localhost/db",
            ...     pool_size=10,
            ... )
        """
        self.postgres_url = postgres_url
    
        try:
            # Create engine with connection pool
            self.engine = create_engine(
                postgres_url,
                poolclass=QueuePool,
                pool_size=pool_size,
                max_overflow=max_overflow,
                pool_timeout=pool_timeout,
                pool_pre_ping=True,  # Verify connections before use
                echo=False,
            )
    
            # Create session factory
            self.session_factory = sessionmaker(bind=self.engine)
    
            # Create tables (idempotent)
            Base.metadata.create_all(self.engine)
    
            logger.info(
                "TokenStorageService initialized",
                extra={
                    "pool_size": pool_size,
                    "max_overflow": max_overflow,
                },
            )
    
        except Exception as e:
&gt;           raise StorageError(
                f"Failed to initialize TokenStorageService: {e}",
                details={"error": str(e)},
            ) from e
E           lark_service.core.exceptions.StorageError: Failed to initialize TokenStorageService: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E           	Is the server running on that host and accepting TCP/IP connections?
E           connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E           	Is the server running on that host and accepting TCP/IP connections?
E           
E           (Background on this error at: https://sqlalche.me/e/20/e3q8)

src/lark_service/core/storage/postgres_storage.py:84: StorageError</error></testcase><testcase classname="tests.integration.test_credential_pool.TestCredentialPoolIntegration" name="test_database_persistence" time="0.007"><error message="failed on setup with &quot;lark_service.core.exceptions.StorageError: Failed to initialize TokenStorageService: (psycopg2.OperationalError) connection to server at &quot;localhost&quot; (::1), port 5432 failed: Connection refused&#10;&#09;Is the server running on that host and accepting TCP/IP connections?&#10;connection to server at &quot;localhost&quot; (127.0.0.1), port 5432 failed: Connection refused&#10;&#09;Is the server running on that host and accepting TCP/IP connections?&#10;&#10;(Background on this error at: https://sqlalche.me/e/20/e3q8)&quot;">self = &lt;sqlalchemy.engine.base.Connection object at 0x7fa854f2da30&gt;
engine = Engine(postgresql://lark:***@localhost:5432/lark_service)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
&gt;               self._dbapi_connection = engine.raw_connection()
                                         ^^^^^^^^^^^^^^^^^^^^^^^

/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lark_service user=lark password=lark_password_123 port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lark_service', 'host': 'localhost', 'password': 'lark_password_123', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
&gt;       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

self = &lt;lark_service.core.storage.postgres_storage.TokenStorageService object at 0x7fa854f2dc70&gt;
postgres_url = 'postgresql://lark:lark_password_123@localhost:5432/lark_service'
pool_size = 10, max_overflow = 20, pool_timeout = 30

    def __init__(
        self,
        postgres_url: str,
        pool_size: int = 10,
        max_overflow: int = 20,
        pool_timeout: int = 30,
    ) -&gt; None:
        """Initialize TokenStorageService.
    
        Args:
            postgres_url: PostgreSQL connection URL
            pool_size: Number of connections to maintain in pool
            max_overflow: Maximum overflow connections
            pool_timeout: Timeout for getting connection from pool (seconds)
    
        Raises:
            StorageError: If database initialization fails
    
        Example:
            &gt;&gt;&gt; service = TokenStorageService(
            ...     "postgresql://user:pass@localhost/db",
            ...     pool_size=10,
            ... )
        """
        self.postgres_url = postgres_url
    
        try:
            # Create engine with connection pool
            self.engine = create_engine(
                postgres_url,
                poolclass=QueuePool,
                pool_size=pool_size,
                max_overflow=max_overflow,
                pool_timeout=pool_timeout,
                pool_pre_ping=True,  # Verify connections before use
                echo=False,
            )
    
            # Create session factory
            self.session_factory = sessionmaker(bind=self.engine)
    
            # Create tables (idempotent)
&gt;           Base.metadata.create_all(self.engine)

src/lark_service/core/storage/postgres_storage.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5928: in create_all
    bind._run_ddl_visitor(
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3259: in _run_ddl_visitor
    with self.begin() as conn:
         ^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3249: in begin
    with self.connect() as conn:
         ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3285: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:145: in __init__
    Connection._handle_dbapi_exception_noconnection(
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2448: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lark_service user=lark password=lark_password_123 port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lark_service', 'host': 'localhost', 'password': 'lark_password_123', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
&gt;       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

test_config = Config(postgres_host='localhost', postgres_port=5432, postgres_db='lark_service', postgres_user='lark', postgres_passw...se_persistence0/test_config.db'), log_level='INFO', max_retries=3, retry_backoff_base=1.0, token_refresh_threshold=0.1)

    @pytest.fixture
    def token_storage(test_config: Config) -&gt; TokenStorageService:
        """Create TokenStorageService for tests."""
&gt;       service = TokenStorageService(test_config.get_postgres_url())
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/integration/test_credential_pool.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;lark_service.core.storage.postgres_storage.TokenStorageService object at 0x7fa854f2dc70&gt;
postgres_url = 'postgresql://lark:lark_password_123@localhost:5432/lark_service'
pool_size = 10, max_overflow = 20, pool_timeout = 30

    def __init__(
        self,
        postgres_url: str,
        pool_size: int = 10,
        max_overflow: int = 20,
        pool_timeout: int = 30,
    ) -&gt; None:
        """Initialize TokenStorageService.
    
        Args:
            postgres_url: PostgreSQL connection URL
            pool_size: Number of connections to maintain in pool
            max_overflow: Maximum overflow connections
            pool_timeout: Timeout for getting connection from pool (seconds)
    
        Raises:
            StorageError: If database initialization fails
    
        Example:
            &gt;&gt;&gt; service = TokenStorageService(
            ...     "postgresql://user:pass@localhost/db",
            ...     pool_size=10,
            ... )
        """
        self.postgres_url = postgres_url
    
        try:
            # Create engine with connection pool
            self.engine = create_engine(
                postgres_url,
                poolclass=QueuePool,
                pool_size=pool_size,
                max_overflow=max_overflow,
                pool_timeout=pool_timeout,
                pool_pre_ping=True,  # Verify connections before use
                echo=False,
            )
    
            # Create session factory
            self.session_factory = sessionmaker(bind=self.engine)
    
            # Create tables (idempotent)
            Base.metadata.create_all(self.engine)
    
            logger.info(
                "TokenStorageService initialized",
                extra={
                    "pool_size": pool_size,
                    "max_overflow": max_overflow,
                },
            )
    
        except Exception as e:
&gt;           raise StorageError(
                f"Failed to initialize TokenStorageService: {e}",
                details={"error": str(e)},
            ) from e
E           lark_service.core.exceptions.StorageError: Failed to initialize TokenStorageService: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E           	Is the server running on that host and accepting TCP/IP connections?
E           connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E           	Is the server running on that host and accepting TCP/IP connections?
E           
E           (Background on this error at: https://sqlalche.me/e/20/e3q8)

src/lark_service/core/storage/postgres_storage.py:84: StorageError</error></testcase><testcase classname="tests.integration.test_credential_pool.TestCredentialPoolIntegration" name="test_multi_app_isolation" time="0.007"><error message="failed on setup with &quot;lark_service.core.exceptions.StorageError: Failed to initialize TokenStorageService: (psycopg2.OperationalError) connection to server at &quot;localhost&quot; (::1), port 5432 failed: Connection refused&#10;&#09;Is the server running on that host and accepting TCP/IP connections?&#10;connection to server at &quot;localhost&quot; (127.0.0.1), port 5432 failed: Connection refused&#10;&#09;Is the server running on that host and accepting TCP/IP connections?&#10;&#10;(Background on this error at: https://sqlalche.me/e/20/e3q8)&quot;">self = &lt;sqlalchemy.engine.base.Connection object at 0x7fa854f6f740&gt;
engine = Engine(postgresql://lark:***@localhost:5432/lark_service)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
&gt;               self._dbapi_connection = engine.raw_connection()
                                         ^^^^^^^^^^^^^^^^^^^^^^^

/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lark_service user=lark password=lark_password_123 port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lark_service', 'host': 'localhost', 'password': 'lark_password_123', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
&gt;       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

self = &lt;lark_service.core.storage.postgres_storage.TokenStorageService object at 0x7fa854f2e210&gt;
postgres_url = 'postgresql://lark:lark_password_123@localhost:5432/lark_service'
pool_size = 10, max_overflow = 20, pool_timeout = 30

    def __init__(
        self,
        postgres_url: str,
        pool_size: int = 10,
        max_overflow: int = 20,
        pool_timeout: int = 30,
    ) -&gt; None:
        """Initialize TokenStorageService.
    
        Args:
            postgres_url: PostgreSQL connection URL
            pool_size: Number of connections to maintain in pool
            max_overflow: Maximum overflow connections
            pool_timeout: Timeout for getting connection from pool (seconds)
    
        Raises:
            StorageError: If database initialization fails
    
        Example:
            &gt;&gt;&gt; service = TokenStorageService(
            ...     "postgresql://user:pass@localhost/db",
            ...     pool_size=10,
            ... )
        """
        self.postgres_url = postgres_url
    
        try:
            # Create engine with connection pool
            self.engine = create_engine(
                postgres_url,
                poolclass=QueuePool,
                pool_size=pool_size,
                max_overflow=max_overflow,
                pool_timeout=pool_timeout,
                pool_pre_ping=True,  # Verify connections before use
                echo=False,
            )
    
            # Create session factory
            self.session_factory = sessionmaker(bind=self.engine)
    
            # Create tables (idempotent)
&gt;           Base.metadata.create_all(self.engine)

src/lark_service/core/storage/postgres_storage.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5928: in create_all
    bind._run_ddl_visitor(
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3259: in _run_ddl_visitor
    with self.begin() as conn:
         ^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3249: in begin
    with self.connect() as conn:
         ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3285: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:145: in __init__
    Connection._handle_dbapi_exception_noconnection(
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2448: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lark_service user=lark password=lark_password_123 port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lark_service', 'host': 'localhost', 'password': 'lark_password_123', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
&gt;       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

test_config = Config(postgres_host='localhost', postgres_port=5432, postgres_db='lark_service', postgres_user='lark', postgres_passw..._app_isolation0/test_config.db'), log_level='INFO', max_retries=3, retry_backoff_base=1.0, token_refresh_threshold=0.1)

    @pytest.fixture
    def token_storage(test_config: Config) -&gt; TokenStorageService:
        """Create TokenStorageService for tests."""
&gt;       service = TokenStorageService(test_config.get_postgres_url())
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/integration/test_credential_pool.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;lark_service.core.storage.postgres_storage.TokenStorageService object at 0x7fa854f2e210&gt;
postgres_url = 'postgresql://lark:lark_password_123@localhost:5432/lark_service'
pool_size = 10, max_overflow = 20, pool_timeout = 30

    def __init__(
        self,
        postgres_url: str,
        pool_size: int = 10,
        max_overflow: int = 20,
        pool_timeout: int = 30,
    ) -&gt; None:
        """Initialize TokenStorageService.
    
        Args:
            postgres_url: PostgreSQL connection URL
            pool_size: Number of connections to maintain in pool
            max_overflow: Maximum overflow connections
            pool_timeout: Timeout for getting connection from pool (seconds)
    
        Raises:
            StorageError: If database initialization fails
    
        Example:
            &gt;&gt;&gt; service = TokenStorageService(
            ...     "postgresql://user:pass@localhost/db",
            ...     pool_size=10,
            ... )
        """
        self.postgres_url = postgres_url
    
        try:
            # Create engine with connection pool
            self.engine = create_engine(
                postgres_url,
                poolclass=QueuePool,
                pool_size=pool_size,
                max_overflow=max_overflow,
                pool_timeout=pool_timeout,
                pool_pre_ping=True,  # Verify connections before use
                echo=False,
            )
    
            # Create session factory
            self.session_factory = sessionmaker(bind=self.engine)
    
            # Create tables (idempotent)
            Base.metadata.create_all(self.engine)
    
            logger.info(
                "TokenStorageService initialized",
                extra={
                    "pool_size": pool_size,
                    "max_overflow": max_overflow,
                },
            )
    
        except Exception as e:
&gt;           raise StorageError(
                f"Failed to initialize TokenStorageService: {e}",
                details={"error": str(e)},
            ) from e
E           lark_service.core.exceptions.StorageError: Failed to initialize TokenStorageService: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E           	Is the server running on that host and accepting TCP/IP connections?
E           connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E           	Is the server running on that host and accepting TCP/IP connections?
E           
E           (Background on this error at: https://sqlalche.me/e/20/e3q8)

src/lark_service/core/storage/postgres_storage.py:84: StorageError</error></testcase><testcase classname="tests.integration.test_credential_pool.TestCredentialPoolIntegration" name="test_force_refresh" time="0.007"><error message="failed on setup with &quot;lark_service.core.exceptions.StorageError: Failed to initialize TokenStorageService: (psycopg2.OperationalError) connection to server at &quot;localhost&quot; (::1), port 5432 failed: Connection refused&#10;&#09;Is the server running on that host and accepting TCP/IP connections?&#10;connection to server at &quot;localhost&quot; (127.0.0.1), port 5432 failed: Connection refused&#10;&#09;Is the server running on that host and accepting TCP/IP connections?&#10;&#10;(Background on this error at: https://sqlalche.me/e/20/e3q8)&quot;">self = &lt;sqlalchemy.engine.base.Connection object at 0x7fa854f7c590&gt;
engine = Engine(postgresql://lark:***@localhost:5432/lark_service)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
&gt;               self._dbapi_connection = engine.raw_connection()
                                         ^^^^^^^^^^^^^^^^^^^^^^^

/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lark_service user=lark password=lark_password_123 port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lark_service', 'host': 'localhost', 'password': 'lark_password_123', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
&gt;       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

self = &lt;lark_service.core.storage.postgres_storage.TokenStorageService object at 0x7fa854f6d220&gt;
postgres_url = 'postgresql://lark:lark_password_123@localhost:5432/lark_service'
pool_size = 10, max_overflow = 20, pool_timeout = 30

    def __init__(
        self,
        postgres_url: str,
        pool_size: int = 10,
        max_overflow: int = 20,
        pool_timeout: int = 30,
    ) -&gt; None:
        """Initialize TokenStorageService.
    
        Args:
            postgres_url: PostgreSQL connection URL
            pool_size: Number of connections to maintain in pool
            max_overflow: Maximum overflow connections
            pool_timeout: Timeout for getting connection from pool (seconds)
    
        Raises:
            StorageError: If database initialization fails
    
        Example:
            &gt;&gt;&gt; service = TokenStorageService(
            ...     "postgresql://user:pass@localhost/db",
            ...     pool_size=10,
            ... )
        """
        self.postgres_url = postgres_url
    
        try:
            # Create engine with connection pool
            self.engine = create_engine(
                postgres_url,
                poolclass=QueuePool,
                pool_size=pool_size,
                max_overflow=max_overflow,
                pool_timeout=pool_timeout,
                pool_pre_ping=True,  # Verify connections before use
                echo=False,
            )
    
            # Create session factory
            self.session_factory = sessionmaker(bind=self.engine)
    
            # Create tables (idempotent)
&gt;           Base.metadata.create_all(self.engine)

src/lark_service/core/storage/postgres_storage.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5928: in create_all
    bind._run_ddl_visitor(
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3259: in _run_ddl_visitor
    with self.begin() as conn:
         ^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3249: in begin
    with self.connect() as conn:
         ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3285: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:145: in __init__
    Connection._handle_dbapi_exception_noconnection(
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2448: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lark_service user=lark password=lark_password_123 port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lark_service', 'host': 'localhost', 'password': 'lark_password_123', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
&gt;       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

test_config = Config(postgres_host='localhost', postgres_port=5432, postgres_db='lark_service', postgres_user='lark', postgres_passw..._force_refresh0/test_config.db'), log_level='INFO', max_retries=3, retry_backoff_base=1.0, token_refresh_threshold=0.1)

    @pytest.fixture
    def token_storage(test_config: Config) -&gt; TokenStorageService:
        """Create TokenStorageService for tests."""
&gt;       service = TokenStorageService(test_config.get_postgres_url())
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/integration/test_credential_pool.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;lark_service.core.storage.postgres_storage.TokenStorageService object at 0x7fa854f6d220&gt;
postgres_url = 'postgresql://lark:lark_password_123@localhost:5432/lark_service'
pool_size = 10, max_overflow = 20, pool_timeout = 30

    def __init__(
        self,
        postgres_url: str,
        pool_size: int = 10,
        max_overflow: int = 20,
        pool_timeout: int = 30,
    ) -&gt; None:
        """Initialize TokenStorageService.
    
        Args:
            postgres_url: PostgreSQL connection URL
            pool_size: Number of connections to maintain in pool
            max_overflow: Maximum overflow connections
            pool_timeout: Timeout for getting connection from pool (seconds)
    
        Raises:
            StorageError: If database initialization fails
    
        Example:
            &gt;&gt;&gt; service = TokenStorageService(
            ...     "postgresql://user:pass@localhost/db",
            ...     pool_size=10,
            ... )
        """
        self.postgres_url = postgres_url
    
        try:
            # Create engine with connection pool
            self.engine = create_engine(
                postgres_url,
                poolclass=QueuePool,
                pool_size=pool_size,
                max_overflow=max_overflow,
                pool_timeout=pool_timeout,
                pool_pre_ping=True,  # Verify connections before use
                echo=False,
            )
    
            # Create session factory
            self.session_factory = sessionmaker(bind=self.engine)
    
            # Create tables (idempotent)
            Base.metadata.create_all(self.engine)
    
            logger.info(
                "TokenStorageService initialized",
                extra={
                    "pool_size": pool_size,
                    "max_overflow": max_overflow,
                },
            )
    
        except Exception as e:
&gt;           raise StorageError(
                f"Failed to initialize TokenStorageService: {e}",
                details={"error": str(e)},
            ) from e
E           lark_service.core.exceptions.StorageError: Failed to initialize TokenStorageService: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E           	Is the server running on that host and accepting TCP/IP connections?
E           connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E           	Is the server running on that host and accepting TCP/IP connections?
E           
E           (Background on this error at: https://sqlalche.me/e/20/e3q8)

src/lark_service/core/storage/postgres_storage.py:84: StorageError</error></testcase><testcase classname="tests.integration.test_credential_pool.TestCredentialPoolIntegration" name="test_invalid_app_id" time="0.007"><error message="failed on setup with &quot;lark_service.core.exceptions.StorageError: Failed to initialize TokenStorageService: (psycopg2.OperationalError) connection to server at &quot;localhost&quot; (::1), port 5432 failed: Connection refused&#10;&#09;Is the server running on that host and accepting TCP/IP connections?&#10;connection to server at &quot;localhost&quot; (127.0.0.1), port 5432 failed: Connection refused&#10;&#09;Is the server running on that host and accepting TCP/IP connections?&#10;&#10;(Background on this error at: https://sqlalche.me/e/20/e3q8)&quot;">self = &lt;sqlalchemy.engine.base.Connection object at 0x7fa854f7f2f0&gt;
engine = Engine(postgresql://lark:***@localhost:5432/lark_service)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
&gt;               self._dbapi_connection = engine.raw_connection()
                                         ^^^^^^^^^^^^^^^^^^^^^^^

/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lark_service user=lark password=lark_password_123 port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lark_service', 'host': 'localhost', 'password': 'lark_password_123', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
&gt;       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

self = &lt;lark_service.core.storage.postgres_storage.TokenStorageService object at 0x7fa854f7de20&gt;
postgres_url = 'postgresql://lark:lark_password_123@localhost:5432/lark_service'
pool_size = 10, max_overflow = 20, pool_timeout = 30

    def __init__(
        self,
        postgres_url: str,
        pool_size: int = 10,
        max_overflow: int = 20,
        pool_timeout: int = 30,
    ) -&gt; None:
        """Initialize TokenStorageService.
    
        Args:
            postgres_url: PostgreSQL connection URL
            pool_size: Number of connections to maintain in pool
            max_overflow: Maximum overflow connections
            pool_timeout: Timeout for getting connection from pool (seconds)
    
        Raises:
            StorageError: If database initialization fails
    
        Example:
            &gt;&gt;&gt; service = TokenStorageService(
            ...     "postgresql://user:pass@localhost/db",
            ...     pool_size=10,
            ... )
        """
        self.postgres_url = postgres_url
    
        try:
            # Create engine with connection pool
            self.engine = create_engine(
                postgres_url,
                poolclass=QueuePool,
                pool_size=pool_size,
                max_overflow=max_overflow,
                pool_timeout=pool_timeout,
                pool_pre_ping=True,  # Verify connections before use
                echo=False,
            )
    
            # Create session factory
            self.session_factory = sessionmaker(bind=self.engine)
    
            # Create tables (idempotent)
&gt;           Base.metadata.create_all(self.engine)

src/lark_service/core/storage/postgres_storage.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5928: in create_all
    bind._run_ddl_visitor(
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3259: in _run_ddl_visitor
    with self.begin() as conn:
         ^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3249: in begin
    with self.connect() as conn:
         ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3285: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:145: in __init__
    Connection._handle_dbapi_exception_noconnection(
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2448: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lark_service user=lark password=lark_password_123 port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lark_service', 'host': 'localhost', 'password': 'lark_password_123', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
&gt;       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

test_config = Config(postgres_host='localhost', postgres_port=5432, postgres_db='lark_service', postgres_user='lark', postgres_passw...invalid_app_id0/test_config.db'), log_level='INFO', max_retries=3, retry_backoff_base=1.0, token_refresh_threshold=0.1)

    @pytest.fixture
    def token_storage(test_config: Config) -&gt; TokenStorageService:
        """Create TokenStorageService for tests."""
&gt;       service = TokenStorageService(test_config.get_postgres_url())
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/integration/test_credential_pool.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;lark_service.core.storage.postgres_storage.TokenStorageService object at 0x7fa854f7de20&gt;
postgres_url = 'postgresql://lark:lark_password_123@localhost:5432/lark_service'
pool_size = 10, max_overflow = 20, pool_timeout = 30

    def __init__(
        self,
        postgres_url: str,
        pool_size: int = 10,
        max_overflow: int = 20,
        pool_timeout: int = 30,
    ) -&gt; None:
        """Initialize TokenStorageService.
    
        Args:
            postgres_url: PostgreSQL connection URL
            pool_size: Number of connections to maintain in pool
            max_overflow: Maximum overflow connections
            pool_timeout: Timeout for getting connection from pool (seconds)
    
        Raises:
            StorageError: If database initialization fails
    
        Example:
            &gt;&gt;&gt; service = TokenStorageService(
            ...     "postgresql://user:pass@localhost/db",
            ...     pool_size=10,
            ... )
        """
        self.postgres_url = postgres_url
    
        try:
            # Create engine with connection pool
            self.engine = create_engine(
                postgres_url,
                poolclass=QueuePool,
                pool_size=pool_size,
                max_overflow=max_overflow,
                pool_timeout=pool_timeout,
                pool_pre_ping=True,  # Verify connections before use
                echo=False,
            )
    
            # Create session factory
            self.session_factory = sessionmaker(bind=self.engine)
    
            # Create tables (idempotent)
            Base.metadata.create_all(self.engine)
    
            logger.info(
                "TokenStorageService initialized",
                extra={
                    "pool_size": pool_size,
                    "max_overflow": max_overflow,
                },
            )
    
        except Exception as e:
&gt;           raise StorageError(
                f"Failed to initialize TokenStorageService: {e}",
                details={"error": str(e)},
            ) from e
E           lark_service.core.exceptions.StorageError: Failed to initialize TokenStorageService: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E           	Is the server running on that host and accepting TCP/IP connections?
E           connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E           	Is the server running on that host and accepting TCP/IP connections?
E           
E           (Background on this error at: https://sqlalche.me/e/20/e3q8)

src/lark_service/core/storage/postgres_storage.py:84: StorageError</error></testcase><testcase classname="tests.integration.test_credential_pool.TestCredentialPoolIntegration" name="test_inactive_app" time="0.007"><error message="failed on setup with &quot;lark_service.core.exceptions.StorageError: Failed to initialize TokenStorageService: (psycopg2.OperationalError) connection to server at &quot;localhost&quot; (::1), port 5432 failed: Connection refused&#10;&#09;Is the server running on that host and accepting TCP/IP connections?&#10;connection to server at &quot;localhost&quot; (127.0.0.1), port 5432 failed: Connection refused&#10;&#09;Is the server running on that host and accepting TCP/IP connections?&#10;&#10;(Background on this error at: https://sqlalche.me/e/20/e3q8)&quot;">self = &lt;sqlalchemy.engine.base.Connection object at 0x7fa854f92690&gt;
engine = Engine(postgresql://lark:***@localhost:5432/lark_service)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
&gt;               self._dbapi_connection = engine.raw_connection()
                                         ^^^^^^^^^^^^^^^^^^^^^^^

/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lark_service user=lark password=lark_password_123 port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lark_service', 'host': 'localhost', 'password': 'lark_password_123', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
&gt;       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

self = &lt;lark_service.core.storage.postgres_storage.TokenStorageService object at 0x7fa854f91310&gt;
postgres_url = 'postgresql://lark:lark_password_123@localhost:5432/lark_service'
pool_size = 10, max_overflow = 20, pool_timeout = 30

    def __init__(
        self,
        postgres_url: str,
        pool_size: int = 10,
        max_overflow: int = 20,
        pool_timeout: int = 30,
    ) -&gt; None:
        """Initialize TokenStorageService.
    
        Args:
            postgres_url: PostgreSQL connection URL
            pool_size: Number of connections to maintain in pool
            max_overflow: Maximum overflow connections
            pool_timeout: Timeout for getting connection from pool (seconds)
    
        Raises:
            StorageError: If database initialization fails
    
        Example:
            &gt;&gt;&gt; service = TokenStorageService(
            ...     "postgresql://user:pass@localhost/db",
            ...     pool_size=10,
            ... )
        """
        self.postgres_url = postgres_url
    
        try:
            # Create engine with connection pool
            self.engine = create_engine(
                postgres_url,
                poolclass=QueuePool,
                pool_size=pool_size,
                max_overflow=max_overflow,
                pool_timeout=pool_timeout,
                pool_pre_ping=True,  # Verify connections before use
                echo=False,
            )
    
            # Create session factory
            self.session_factory = sessionmaker(bind=self.engine)
    
            # Create tables (idempotent)
&gt;           Base.metadata.create_all(self.engine)

src/lark_service/core/storage/postgres_storage.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5928: in create_all
    bind._run_ddl_visitor(
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3259: in _run_ddl_visitor
    with self.begin() as conn:
         ^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3249: in begin
    with self.connect() as conn:
         ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3285: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:145: in __init__
    Connection._handle_dbapi_exception_noconnection(
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2448: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lark_service user=lark password=lark_password_123 port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lark_service', 'host': 'localhost', 'password': 'lark_password_123', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
&gt;       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

test_config = Config(postgres_host='localhost', postgres_port=5432, postgres_db='lark_service', postgres_user='lark', postgres_passw...t_inactive_app0/test_config.db'), log_level='INFO', max_retries=3, retry_backoff_base=1.0, token_refresh_threshold=0.1)

    @pytest.fixture
    def token_storage(test_config: Config) -&gt; TokenStorageService:
        """Create TokenStorageService for tests."""
&gt;       service = TokenStorageService(test_config.get_postgres_url())
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/integration/test_credential_pool.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;lark_service.core.storage.postgres_storage.TokenStorageService object at 0x7fa854f91310&gt;
postgres_url = 'postgresql://lark:lark_password_123@localhost:5432/lark_service'
pool_size = 10, max_overflow = 20, pool_timeout = 30

    def __init__(
        self,
        postgres_url: str,
        pool_size: int = 10,
        max_overflow: int = 20,
        pool_timeout: int = 30,
    ) -&gt; None:
        """Initialize TokenStorageService.
    
        Args:
            postgres_url: PostgreSQL connection URL
            pool_size: Number of connections to maintain in pool
            max_overflow: Maximum overflow connections
            pool_timeout: Timeout for getting connection from pool (seconds)
    
        Raises:
            StorageError: If database initialization fails
    
        Example:
            &gt;&gt;&gt; service = TokenStorageService(
            ...     "postgresql://user:pass@localhost/db",
            ...     pool_size=10,
            ... )
        """
        self.postgres_url = postgres_url
    
        try:
            # Create engine with connection pool
            self.engine = create_engine(
                postgres_url,
                poolclass=QueuePool,
                pool_size=pool_size,
                max_overflow=max_overflow,
                pool_timeout=pool_timeout,
                pool_pre_ping=True,  # Verify connections before use
                echo=False,
            )
    
            # Create session factory
            self.session_factory = sessionmaker(bind=self.engine)
    
            # Create tables (idempotent)
            Base.metadata.create_all(self.engine)
    
            logger.info(
                "TokenStorageService initialized",
                extra={
                    "pool_size": pool_size,
                    "max_overflow": max_overflow,
                },
            )
    
        except Exception as e:
&gt;           raise StorageError(
                f"Failed to initialize TokenStorageService: {e}",
                details={"error": str(e)},
            ) from e
E           lark_service.core.exceptions.StorageError: Failed to initialize TokenStorageService: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E           	Is the server running on that host and accepting TCP/IP connections?
E           connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E           	Is the server running on that host and accepting TCP/IP connections?
E           
E           (Background on this error at: https://sqlalche.me/e/20/e3q8)

src/lark_service/core/storage/postgres_storage.py:84: StorageError</error></testcase><testcase classname="tests.integration.test_credential_pool.TestCredentialPoolIntegration" name="test_token_invalidation" time="0.007"><error message="failed on setup with &quot;lark_service.core.exceptions.StorageError: Failed to initialize TokenStorageService: (psycopg2.OperationalError) connection to server at &quot;localhost&quot; (::1), port 5432 failed: Connection refused&#10;&#09;Is the server running on that host and accepting TCP/IP connections?&#10;connection to server at &quot;localhost&quot; (127.0.0.1), port 5432 failed: Connection refused&#10;&#09;Is the server running on that host and accepting TCP/IP connections?&#10;&#10;(Background on this error at: https://sqlalche.me/e/20/e3q8)&quot;">self = &lt;sqlalchemy.engine.base.Connection object at 0x7fa854f79940&gt;
engine = Engine(postgresql://lark:***@localhost:5432/lark_service)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
&gt;               self._dbapi_connection = engine.raw_connection()
                                         ^^^^^^^^^^^^^^^^^^^^^^^

/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lark_service user=lark password=lark_password_123 port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lark_service', 'host': 'localhost', 'password': 'lark_password_123', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
&gt;       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

self = &lt;lark_service.core.storage.postgres_storage.TokenStorageService object at 0x7fa854f7b0b0&gt;
postgres_url = 'postgresql://lark:lark_password_123@localhost:5432/lark_service'
pool_size = 10, max_overflow = 20, pool_timeout = 30

    def __init__(
        self,
        postgres_url: str,
        pool_size: int = 10,
        max_overflow: int = 20,
        pool_timeout: int = 30,
    ) -&gt; None:
        """Initialize TokenStorageService.
    
        Args:
            postgres_url: PostgreSQL connection URL
            pool_size: Number of connections to maintain in pool
            max_overflow: Maximum overflow connections
            pool_timeout: Timeout for getting connection from pool (seconds)
    
        Raises:
            StorageError: If database initialization fails
    
        Example:
            &gt;&gt;&gt; service = TokenStorageService(
            ...     "postgresql://user:pass@localhost/db",
            ...     pool_size=10,
            ... )
        """
        self.postgres_url = postgres_url
    
        try:
            # Create engine with connection pool
            self.engine = create_engine(
                postgres_url,
                poolclass=QueuePool,
                pool_size=pool_size,
                max_overflow=max_overflow,
                pool_timeout=pool_timeout,
                pool_pre_ping=True,  # Verify connections before use
                echo=False,
            )
    
            # Create session factory
            self.session_factory = sessionmaker(bind=self.engine)
    
            # Create tables (idempotent)
&gt;           Base.metadata.create_all(self.engine)

src/lark_service/core/storage/postgres_storage.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5928: in create_all
    bind._run_ddl_visitor(
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3259: in _run_ddl_visitor
    with self.begin() as conn:
         ^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3249: in begin
    with self.connect() as conn:
         ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3285: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:145: in __init__
    Connection._handle_dbapi_exception_noconnection(
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2448: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lark_service user=lark password=lark_password_123 port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lark_service', 'host': 'localhost', 'password': 'lark_password_123', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
&gt;       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

test_config = Config(postgres_host='localhost', postgres_port=5432, postgres_db='lark_service', postgres_user='lark', postgres_passw...n_invalidation0/test_config.db'), log_level='INFO', max_retries=3, retry_backoff_base=1.0, token_refresh_threshold=0.1)

    @pytest.fixture
    def token_storage(test_config: Config) -&gt; TokenStorageService:
        """Create TokenStorageService for tests."""
&gt;       service = TokenStorageService(test_config.get_postgres_url())
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/integration/test_credential_pool.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;lark_service.core.storage.postgres_storage.TokenStorageService object at 0x7fa854f7b0b0&gt;
postgres_url = 'postgresql://lark:lark_password_123@localhost:5432/lark_service'
pool_size = 10, max_overflow = 20, pool_timeout = 30

    def __init__(
        self,
        postgres_url: str,
        pool_size: int = 10,
        max_overflow: int = 20,
        pool_timeout: int = 30,
    ) -&gt; None:
        """Initialize TokenStorageService.
    
        Args:
            postgres_url: PostgreSQL connection URL
            pool_size: Number of connections to maintain in pool
            max_overflow: Maximum overflow connections
            pool_timeout: Timeout for getting connection from pool (seconds)
    
        Raises:
            StorageError: If database initialization fails
    
        Example:
            &gt;&gt;&gt; service = TokenStorageService(
            ...     "postgresql://user:pass@localhost/db",
            ...     pool_size=10,
            ... )
        """
        self.postgres_url = postgres_url
    
        try:
            # Create engine with connection pool
            self.engine = create_engine(
                postgres_url,
                poolclass=QueuePool,
                pool_size=pool_size,
                max_overflow=max_overflow,
                pool_timeout=pool_timeout,
                pool_pre_ping=True,  # Verify connections before use
                echo=False,
            )
    
            # Create session factory
            self.session_factory = sessionmaker(bind=self.engine)
    
            # Create tables (idempotent)
            Base.metadata.create_all(self.engine)
    
            logger.info(
                "TokenStorageService initialized",
                extra={
                    "pool_size": pool_size,
                    "max_overflow": max_overflow,
                },
            )
    
        except Exception as e:
&gt;           raise StorageError(
                f"Failed to initialize TokenStorageService: {e}",
                details={"error": str(e)},
            ) from e
E           lark_service.core.exceptions.StorageError: Failed to initialize TokenStorageService: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E           	Is the server running on that host and accepting TCP/IP connections?
E           connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E           	Is the server running on that host and accepting TCP/IP connections?
E           
E           (Background on this error at: https://sqlalche.me/e/20/e3q8)

src/lark_service/core/storage/postgres_storage.py:84: StorageError</error></testcase><testcase classname="tests.integration.test_token_lifecycle.TestTokenLifecycle" name="test_complete_lifecycle" time="0.025"><error message="failed on setup with &quot;lark_service.core.exceptions.StorageError: Failed to initialize TokenStorageService: (psycopg2.OperationalError) connection to server at &quot;localhost&quot; (::1), port 5432 failed: Connection refused&#10;&#09;Is the server running on that host and accepting TCP/IP connections?&#10;connection to server at &quot;localhost&quot; (127.0.0.1), port 5432 failed: Connection refused&#10;&#09;Is the server running on that host and accepting TCP/IP connections?&#10;&#10;(Background on this error at: https://sqlalche.me/e/20/e3q8)&quot;">self = &lt;sqlalchemy.engine.base.Connection object at 0x7fa85342fe30&gt;
engine = Engine(postgresql://lark:***@localhost:5432/lark_service)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
&gt;               self._dbapi_connection = engine.raw_connection()
                                         ^^^^^^^^^^^^^^^^^^^^^^^

/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lark_service user=lark password=lark_password_123 port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lark_service', 'host': 'localhost', 'password': 'lark_password_123', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
&gt;       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

self = &lt;lark_service.core.storage.postgres_storage.TokenStorageService object at 0x7fa854f7baa0&gt;
postgres_url = 'postgresql://lark:lark_password_123@localhost:5432/lark_service'
pool_size = 10, max_overflow = 20, pool_timeout = 30

    def __init__(
        self,
        postgres_url: str,
        pool_size: int = 10,
        max_overflow: int = 20,
        pool_timeout: int = 30,
    ) -&gt; None:
        """Initialize TokenStorageService.
    
        Args:
            postgres_url: PostgreSQL connection URL
            pool_size: Number of connections to maintain in pool
            max_overflow: Maximum overflow connections
            pool_timeout: Timeout for getting connection from pool (seconds)
    
        Raises:
            StorageError: If database initialization fails
    
        Example:
            &gt;&gt;&gt; service = TokenStorageService(
            ...     "postgresql://user:pass@localhost/db",
            ...     pool_size=10,
            ... )
        """
        self.postgres_url = postgres_url
    
        try:
            # Create engine with connection pool
            self.engine = create_engine(
                postgres_url,
                poolclass=QueuePool,
                pool_size=pool_size,
                max_overflow=max_overflow,
                pool_timeout=pool_timeout,
                pool_pre_ping=True,  # Verify connections before use
                echo=False,
            )
    
            # Create session factory
            self.session_factory = sessionmaker(bind=self.engine)
    
            # Create tables (idempotent)
&gt;           Base.metadata.create_all(self.engine)

src/lark_service/core/storage/postgres_storage.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5928: in create_all
    bind._run_ddl_visitor(
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3259: in _run_ddl_visitor
    with self.begin() as conn:
         ^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3249: in begin
    with self.connect() as conn:
         ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3285: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:145: in __init__
    Connection._handle_dbapi_exception_noconnection(
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2448: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lark_service user=lark password=lark_password_123 port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lark_service', 'host': 'localhost', 'password': 'lark_password_123', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
&gt;       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

test_config = Config(postgres_host='localhost', postgres_port=5432, postgres_db='lark_service', postgres_user='lark', postgres_passw...lete_lifecycle0/test_config.db'), log_level='INFO', max_retries=3, retry_backoff_base=0.1, token_refresh_threshold=0.5)

    @pytest.fixture
    def token_storage(test_config: Config) -&gt; TokenStorageService:
        """Create TokenStorageService for tests."""
&gt;       service = TokenStorageService(test_config.get_postgres_url())
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/integration/test_token_lifecycle.py:63: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;lark_service.core.storage.postgres_storage.TokenStorageService object at 0x7fa854f7baa0&gt;
postgres_url = 'postgresql://lark:lark_password_123@localhost:5432/lark_service'
pool_size = 10, max_overflow = 20, pool_timeout = 30

    def __init__(
        self,
        postgres_url: str,
        pool_size: int = 10,
        max_overflow: int = 20,
        pool_timeout: int = 30,
    ) -&gt; None:
        """Initialize TokenStorageService.
    
        Args:
            postgres_url: PostgreSQL connection URL
            pool_size: Number of connections to maintain in pool
            max_overflow: Maximum overflow connections
            pool_timeout: Timeout for getting connection from pool (seconds)
    
        Raises:
            StorageError: If database initialization fails
    
        Example:
            &gt;&gt;&gt; service = TokenStorageService(
            ...     "postgresql://user:pass@localhost/db",
            ...     pool_size=10,
            ... )
        """
        self.postgres_url = postgres_url
    
        try:
            # Create engine with connection pool
            self.engine = create_engine(
                postgres_url,
                poolclass=QueuePool,
                pool_size=pool_size,
                max_overflow=max_overflow,
                pool_timeout=pool_timeout,
                pool_pre_ping=True,  # Verify connections before use
                echo=False,
            )
    
            # Create session factory
            self.session_factory = sessionmaker(bind=self.engine)
    
            # Create tables (idempotent)
            Base.metadata.create_all(self.engine)
    
            logger.info(
                "TokenStorageService initialized",
                extra={
                    "pool_size": pool_size,
                    "max_overflow": max_overflow,
                },
            )
    
        except Exception as e:
&gt;           raise StorageError(
                f"Failed to initialize TokenStorageService: {e}",
                details={"error": str(e)},
            ) from e
E           lark_service.core.exceptions.StorageError: Failed to initialize TokenStorageService: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E           	Is the server running on that host and accepting TCP/IP connections?
E           connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E           	Is the server running on that host and accepting TCP/IP connections?
E           
E           (Background on this error at: https://sqlalche.me/e/20/e3q8)

src/lark_service/core/storage/postgres_storage.py:84: StorageError</error></testcase><testcase classname="tests.integration.test_token_lifecycle.TestTokenLifecycle" name="test_concurrent_generated_token_access" time="0.016"><error message="failed on setup with &quot;lark_service.core.exceptions.StorageError: Failed to initialize TokenStorageService: (psycopg2.OperationalError) connection to server at &quot;localhost&quot; (::1), port 5432 failed: Connection refused&#10;&#09;Is the server running on that host and accepting TCP/IP connections?&#10;connection to server at &quot;localhost&quot; (127.0.0.1), port 5432 failed: Connection refused&#10;&#09;Is the server running on that host and accepting TCP/IP connections?&#10;&#10;(Background on this error at: https://sqlalche.me/e/20/e3q8)&quot;">self = &lt;sqlalchemy.engine.base.Connection object at 0x7fa8534b4b60&gt;
engine = Engine(postgresql://lark:***@localhost:5432/lark_service)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
&gt;               self._dbapi_connection = engine.raw_connection()
                                         ^^^^^^^^^^^^^^^^^^^^^^^

/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lark_service user=lark password=lark_password_123 port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lark_service', 'host': 'localhost', 'password': 'lark_password_123', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
&gt;       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

self = &lt;lark_service.core.storage.postgres_storage.TokenStorageService object at 0x7fa8534a3620&gt;
postgres_url = 'postgresql://lark:lark_password_123@localhost:5432/lark_service'
pool_size = 10, max_overflow = 20, pool_timeout = 30

    def __init__(
        self,
        postgres_url: str,
        pool_size: int = 10,
        max_overflow: int = 20,
        pool_timeout: int = 30,
    ) -&gt; None:
        """Initialize TokenStorageService.
    
        Args:
            postgres_url: PostgreSQL connection URL
            pool_size: Number of connections to maintain in pool
            max_overflow: Maximum overflow connections
            pool_timeout: Timeout for getting connection from pool (seconds)
    
        Raises:
            StorageError: If database initialization fails
    
        Example:
            &gt;&gt;&gt; service = TokenStorageService(
            ...     "postgresql://user:pass@localhost/db",
            ...     pool_size=10,
            ... )
        """
        self.postgres_url = postgres_url
    
        try:
            # Create engine with connection pool
            self.engine = create_engine(
                postgres_url,
                poolclass=QueuePool,
                pool_size=pool_size,
                max_overflow=max_overflow,
                pool_timeout=pool_timeout,
                pool_pre_ping=True,  # Verify connections before use
                echo=False,
            )
    
            # Create session factory
            self.session_factory = sessionmaker(bind=self.engine)
    
            # Create tables (idempotent)
&gt;           Base.metadata.create_all(self.engine)

src/lark_service/core/storage/postgres_storage.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5928: in create_all
    bind._run_ddl_visitor(
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3259: in _run_ddl_visitor
    with self.begin() as conn:
         ^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3249: in begin
    with self.connect() as conn:
         ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3285: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:145: in __init__
    Connection._handle_dbapi_exception_noconnection(
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2448: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lark_service user=lark password=lark_password_123 port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lark_service', 'host': 'localhost', 'password': 'lark_password_123', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
&gt;       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

test_config = Config(postgres_host='localhost', postgres_port=5432, postgres_db='lark_service', postgres_user='lark', postgres_passw...generated_toke0/test_config.db'), log_level='INFO', max_retries=3, retry_backoff_base=0.1, token_refresh_threshold=0.5)

    @pytest.fixture
    def token_storage(test_config: Config) -&gt; TokenStorageService:
        """Create TokenStorageService for tests."""
&gt;       service = TokenStorageService(test_config.get_postgres_url())
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/integration/test_token_lifecycle.py:63: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;lark_service.core.storage.postgres_storage.TokenStorageService object at 0x7fa8534a3620&gt;
postgres_url = 'postgresql://lark:lark_password_123@localhost:5432/lark_service'
pool_size = 10, max_overflow = 20, pool_timeout = 30

    def __init__(
        self,
        postgres_url: str,
        pool_size: int = 10,
        max_overflow: int = 20,
        pool_timeout: int = 30,
    ) -&gt; None:
        """Initialize TokenStorageService.
    
        Args:
            postgres_url: PostgreSQL connection URL
            pool_size: Number of connections to maintain in pool
            max_overflow: Maximum overflow connections
            pool_timeout: Timeout for getting connection from pool (seconds)
    
        Raises:
            StorageError: If database initialization fails
    
        Example:
            &gt;&gt;&gt; service = TokenStorageService(
            ...     "postgresql://user:pass@localhost/db",
            ...     pool_size=10,
            ... )
        """
        self.postgres_url = postgres_url
    
        try:
            # Create engine with connection pool
            self.engine = create_engine(
                postgres_url,
                poolclass=QueuePool,
                pool_size=pool_size,
                max_overflow=max_overflow,
                pool_timeout=pool_timeout,
                pool_pre_ping=True,  # Verify connections before use
                echo=False,
            )
    
            # Create session factory
            self.session_factory = sessionmaker(bind=self.engine)
    
            # Create tables (idempotent)
            Base.metadata.create_all(self.engine)
    
            logger.info(
                "TokenStorageService initialized",
                extra={
                    "pool_size": pool_size,
                    "max_overflow": max_overflow,
                },
            )
    
        except Exception as e:
&gt;           raise StorageError(
                f"Failed to initialize TokenStorageService: {e}",
                details={"error": str(e)},
            ) from e
E           lark_service.core.exceptions.StorageError: Failed to initialize TokenStorageService: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E           	Is the server running on that host and accepting TCP/IP connections?
E           connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E           	Is the server running on that host and accepting TCP/IP connections?
E           
E           (Background on this error at: https://sqlalche.me/e/20/e3q8)

src/lark_service/core/storage/postgres_storage.py:84: StorageError</error></testcase><testcase classname="tests.integration.test_token_lifecycle.TestTokenLifecycle" name="test_token_refresh_on_near_expiry" time="0.016"><error message="failed on setup with &quot;lark_service.core.exceptions.StorageError: Failed to initialize TokenStorageService: (psycopg2.OperationalError) connection to server at &quot;localhost&quot; (::1), port 5432 failed: Connection refused&#10;&#09;Is the server running on that host and accepting TCP/IP connections?&#10;connection to server at &quot;localhost&quot; (127.0.0.1), port 5432 failed: Connection refused&#10;&#09;Is the server running on that host and accepting TCP/IP connections?&#10;&#10;(Background on this error at: https://sqlalche.me/e/20/e3q8)&quot;">self = &lt;sqlalchemy.engine.base.Connection object at 0x7fa8534992e0&gt;
engine = Engine(postgresql://lark:***@localhost:5432/lark_service)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
&gt;               self._dbapi_connection = engine.raw_connection()
                                         ^^^^^^^^^^^^^^^^^^^^^^^

/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lark_service user=lark password=lark_password_123 port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lark_service', 'host': 'localhost', 'password': 'lark_password_123', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
&gt;       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

self = &lt;lark_service.core.storage.postgres_storage.TokenStorageService object at 0x7fa8534b6360&gt;
postgres_url = 'postgresql://lark:lark_password_123@localhost:5432/lark_service'
pool_size = 10, max_overflow = 20, pool_timeout = 30

    def __init__(
        self,
        postgres_url: str,
        pool_size: int = 10,
        max_overflow: int = 20,
        pool_timeout: int = 30,
    ) -&gt; None:
        """Initialize TokenStorageService.
    
        Args:
            postgres_url: PostgreSQL connection URL
            pool_size: Number of connections to maintain in pool
            max_overflow: Maximum overflow connections
            pool_timeout: Timeout for getting connection from pool (seconds)
    
        Raises:
            StorageError: If database initialization fails
    
        Example:
            &gt;&gt;&gt; service = TokenStorageService(
            ...     "postgresql://user:pass@localhost/db",
            ...     pool_size=10,
            ... )
        """
        self.postgres_url = postgres_url
    
        try:
            # Create engine with connection pool
            self.engine = create_engine(
                postgres_url,
                poolclass=QueuePool,
                pool_size=pool_size,
                max_overflow=max_overflow,
                pool_timeout=pool_timeout,
                pool_pre_ping=True,  # Verify connections before use
                echo=False,
            )
    
            # Create session factory
            self.session_factory = sessionmaker(bind=self.engine)
    
            # Create tables (idempotent)
&gt;           Base.metadata.create_all(self.engine)

src/lark_service/core/storage/postgres_storage.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5928: in create_all
    bind._run_ddl_visitor(
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3259: in _run_ddl_visitor
    with self.begin() as conn:
         ^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3249: in begin
    with self.connect() as conn:
         ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3285: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:145: in __init__
    Connection._handle_dbapi_exception_noconnection(
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2448: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lark_service user=lark password=lark_password_123 port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lark_service', 'host': 'localhost', 'password': 'lark_password_123', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
&gt;       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

test_config = Config(postgres_host='localhost', postgres_port=5432, postgres_db='lark_service', postgres_user='lark', postgres_passw...sh_on_near_exp0/test_config.db'), log_level='INFO', max_retries=3, retry_backoff_base=0.1, token_refresh_threshold=0.5)

    @pytest.fixture
    def token_storage(test_config: Config) -&gt; TokenStorageService:
        """Create TokenStorageService for tests."""
&gt;       service = TokenStorageService(test_config.get_postgres_url())
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/integration/test_token_lifecycle.py:63: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;lark_service.core.storage.postgres_storage.TokenStorageService object at 0x7fa8534b6360&gt;
postgres_url = 'postgresql://lark:lark_password_123@localhost:5432/lark_service'
pool_size = 10, max_overflow = 20, pool_timeout = 30

    def __init__(
        self,
        postgres_url: str,
        pool_size: int = 10,
        max_overflow: int = 20,
        pool_timeout: int = 30,
    ) -&gt; None:
        """Initialize TokenStorageService.
    
        Args:
            postgres_url: PostgreSQL connection URL
            pool_size: Number of connections to maintain in pool
            max_overflow: Maximum overflow connections
            pool_timeout: Timeout for getting connection from pool (seconds)
    
        Raises:
            StorageError: If database initialization fails
    
        Example:
            &gt;&gt;&gt; service = TokenStorageService(
            ...     "postgresql://user:pass@localhost/db",
            ...     pool_size=10,
            ... )
        """
        self.postgres_url = postgres_url
    
        try:
            # Create engine with connection pool
            self.engine = create_engine(
                postgres_url,
                poolclass=QueuePool,
                pool_size=pool_size,
                max_overflow=max_overflow,
                pool_timeout=pool_timeout,
                pool_pre_ping=True,  # Verify connections before use
                echo=False,
            )
    
            # Create session factory
            self.session_factory = sessionmaker(bind=self.engine)
    
            # Create tables (idempotent)
            Base.metadata.create_all(self.engine)
    
            logger.info(
                "TokenStorageService initialized",
                extra={
                    "pool_size": pool_size,
                    "max_overflow": max_overflow,
                },
            )
    
        except Exception as e:
&gt;           raise StorageError(
                f"Failed to initialize TokenStorageService: {e}",
                details={"error": str(e)},
            ) from e
E           lark_service.core.exceptions.StorageError: Failed to initialize TokenStorageService: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E           	Is the server running on that host and accepting TCP/IP connections?
E           connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E           	Is the server running on that host and accepting TCP/IP connections?
E           
E           (Background on this error at: https://sqlalche.me/e/20/e3q8)

src/lark_service/core/storage/postgres_storage.py:84: StorageError</error></testcase><testcase classname="tests.integration.test_token_lifecycle.TestTokenLifecycle" name="test_expired_token_re_acquisition" time="0.015"><error message="failed on setup with &quot;lark_service.core.exceptions.StorageError: Failed to initialize TokenStorageService: (psycopg2.OperationalError) connection to server at &quot;localhost&quot; (::1), port 5432 failed: Connection refused&#10;&#09;Is the server running on that host and accepting TCP/IP connections?&#10;connection to server at &quot;localhost&quot; (127.0.0.1), port 5432 failed: Connection refused&#10;&#09;Is the server running on that host and accepting TCP/IP connections?&#10;&#10;(Background on this error at: https://sqlalche.me/e/20/e3q8)&quot;">self = &lt;sqlalchemy.engine.base.Connection object at 0x7fa8535c60f0&gt;
engine = Engine(postgresql://lark:***@localhost:5432/lark_service)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
&gt;               self._dbapi_connection = engine.raw_connection()
                                         ^^^^^^^^^^^^^^^^^^^^^^^

/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lark_service user=lark password=lark_password_123 port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lark_service', 'host': 'localhost', 'password': 'lark_password_123', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
&gt;       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

self = &lt;lark_service.core.storage.postgres_storage.TokenStorageService object at 0x7fa85349a4e0&gt;
postgres_url = 'postgresql://lark:lark_password_123@localhost:5432/lark_service'
pool_size = 10, max_overflow = 20, pool_timeout = 30

    def __init__(
        self,
        postgres_url: str,
        pool_size: int = 10,
        max_overflow: int = 20,
        pool_timeout: int = 30,
    ) -&gt; None:
        """Initialize TokenStorageService.
    
        Args:
            postgres_url: PostgreSQL connection URL
            pool_size: Number of connections to maintain in pool
            max_overflow: Maximum overflow connections
            pool_timeout: Timeout for getting connection from pool (seconds)
    
        Raises:
            StorageError: If database initialization fails
    
        Example:
            &gt;&gt;&gt; service = TokenStorageService(
            ...     "postgresql://user:pass@localhost/db",
            ...     pool_size=10,
            ... )
        """
        self.postgres_url = postgres_url
    
        try:
            # Create engine with connection pool
            self.engine = create_engine(
                postgres_url,
                poolclass=QueuePool,
                pool_size=pool_size,
                max_overflow=max_overflow,
                pool_timeout=pool_timeout,
                pool_pre_ping=True,  # Verify connections before use
                echo=False,
            )
    
            # Create session factory
            self.session_factory = sessionmaker(bind=self.engine)
    
            # Create tables (idempotent)
&gt;           Base.metadata.create_all(self.engine)

src/lark_service/core/storage/postgres_storage.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5928: in create_all
    bind._run_ddl_visitor(
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3259: in _run_ddl_visitor
    with self.begin() as conn:
         ^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3249: in begin
    with self.connect() as conn:
         ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3285: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:145: in __init__
    Connection._handle_dbapi_exception_noconnection(
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2448: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lark_service user=lark password=lark_password_123 port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lark_service', 'host': 'localhost', 'password': 'lark_password_123', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
&gt;       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

test_config = Config(postgres_host='localhost', postgres_port=5432, postgres_db='lark_service', postgres_user='lark', postgres_passw...en_re_acquisit0/test_config.db'), log_level='INFO', max_retries=3, retry_backoff_base=0.1, token_refresh_threshold=0.5)

    @pytest.fixture
    def token_storage(test_config: Config) -&gt; TokenStorageService:
        """Create TokenStorageService for tests."""
&gt;       service = TokenStorageService(test_config.get_postgres_url())
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/integration/test_token_lifecycle.py:63: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;lark_service.core.storage.postgres_storage.TokenStorageService object at 0x7fa85349a4e0&gt;
postgres_url = 'postgresql://lark:lark_password_123@localhost:5432/lark_service'
pool_size = 10, max_overflow = 20, pool_timeout = 30

    def __init__(
        self,
        postgres_url: str,
        pool_size: int = 10,
        max_overflow: int = 20,
        pool_timeout: int = 30,
    ) -&gt; None:
        """Initialize TokenStorageService.
    
        Args:
            postgres_url: PostgreSQL connection URL
            pool_size: Number of connections to maintain in pool
            max_overflow: Maximum overflow connections
            pool_timeout: Timeout for getting connection from pool (seconds)
    
        Raises:
            StorageError: If database initialization fails
    
        Example:
            &gt;&gt;&gt; service = TokenStorageService(
            ...     "postgresql://user:pass@localhost/db",
            ...     pool_size=10,
            ... )
        """
        self.postgres_url = postgres_url
    
        try:
            # Create engine with connection pool
            self.engine = create_engine(
                postgres_url,
                poolclass=QueuePool,
                pool_size=pool_size,
                max_overflow=max_overflow,
                pool_timeout=pool_timeout,
                pool_pre_ping=True,  # Verify connections before use
                echo=False,
            )
    
            # Create session factory
            self.session_factory = sessionmaker(bind=self.engine)
    
            # Create tables (idempotent)
            Base.metadata.create_all(self.engine)
    
            logger.info(
                "TokenStorageService initialized",
                extra={
                    "pool_size": pool_size,
                    "max_overflow": max_overflow,
                },
            )
    
        except Exception as e:
&gt;           raise StorageError(
                f"Failed to initialize TokenStorageService: {e}",
                details={"error": str(e)},
            ) from e
E           lark_service.core.exceptions.StorageError: Failed to initialize TokenStorageService: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E           	Is the server running on that host and accepting TCP/IP connections?
E           connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E           	Is the server running on that host and accepting TCP/IP connections?
E           
E           (Background on this error at: https://sqlalche.me/e/20/e3q8)

src/lark_service/core/storage/postgres_storage.py:84: StorageError</error></testcase><testcase classname="tests.integration.test_token_lifecycle.TestTokenLifecycle" name="test_token_types_independence" time="0.015"><error message="failed on setup with &quot;lark_service.core.exceptions.StorageError: Failed to initialize TokenStorageService: (psycopg2.OperationalError) connection to server at &quot;localhost&quot; (::1), port 5432 failed: Connection refused&#10;&#09;Is the server running on that host and accepting TCP/IP connections?&#10;connection to server at &quot;localhost&quot; (127.0.0.1), port 5432 failed: Connection refused&#10;&#09;Is the server running on that host and accepting TCP/IP connections?&#10;&#10;(Background on this error at: https://sqlalche.me/e/20/e3q8)&quot;">self = &lt;sqlalchemy.engine.base.Connection object at 0x7fa853513020&gt;
engine = Engine(postgresql://lark:***@localhost:5432/lark_service)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
&gt;               self._dbapi_connection = engine.raw_connection()
                                         ^^^^^^^^^^^^^^^^^^^^^^^

/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lark_service user=lark password=lark_password_123 port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lark_service', 'host': 'localhost', 'password': 'lark_password_123', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
&gt;       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

self = &lt;lark_service.core.storage.postgres_storage.TokenStorageService object at 0x7fa8535c6e10&gt;
postgres_url = 'postgresql://lark:lark_password_123@localhost:5432/lark_service'
pool_size = 10, max_overflow = 20, pool_timeout = 30

    def __init__(
        self,
        postgres_url: str,
        pool_size: int = 10,
        max_overflow: int = 20,
        pool_timeout: int = 30,
    ) -&gt; None:
        """Initialize TokenStorageService.
    
        Args:
            postgres_url: PostgreSQL connection URL
            pool_size: Number of connections to maintain in pool
            max_overflow: Maximum overflow connections
            pool_timeout: Timeout for getting connection from pool (seconds)
    
        Raises:
            StorageError: If database initialization fails
    
        Example:
            &gt;&gt;&gt; service = TokenStorageService(
            ...     "postgresql://user:pass@localhost/db",
            ...     pool_size=10,
            ... )
        """
        self.postgres_url = postgres_url
    
        try:
            # Create engine with connection pool
            self.engine = create_engine(
                postgres_url,
                poolclass=QueuePool,
                pool_size=pool_size,
                max_overflow=max_overflow,
                pool_timeout=pool_timeout,
                pool_pre_ping=True,  # Verify connections before use
                echo=False,
            )
    
            # Create session factory
            self.session_factory = sessionmaker(bind=self.engine)
    
            # Create tables (idempotent)
&gt;           Base.metadata.create_all(self.engine)

src/lark_service/core/storage/postgres_storage.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5928: in create_all
    bind._run_ddl_visitor(
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3259: in _run_ddl_visitor
    with self.begin() as conn:
         ^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3249: in begin
    with self.connect() as conn:
         ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3285: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:145: in __init__
    Connection._handle_dbapi_exception_noconnection(
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2448: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lark_service user=lark password=lark_password_123 port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lark_service', 'host': 'localhost', 'password': 'lark_password_123', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
&gt;       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

test_config = Config(postgres_host='localhost', postgres_port=5432, postgres_db='lark_service', postgres_user='lark', postgres_passw...s_independence0/test_config.db'), log_level='INFO', max_retries=3, retry_backoff_base=0.1, token_refresh_threshold=0.5)

    @pytest.fixture
    def token_storage(test_config: Config) -&gt; TokenStorageService:
        """Create TokenStorageService for tests."""
&gt;       service = TokenStorageService(test_config.get_postgres_url())
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/integration/test_token_lifecycle.py:63: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;lark_service.core.storage.postgres_storage.TokenStorageService object at 0x7fa8535c6e10&gt;
postgres_url = 'postgresql://lark:lark_password_123@localhost:5432/lark_service'
pool_size = 10, max_overflow = 20, pool_timeout = 30

    def __init__(
        self,
        postgres_url: str,
        pool_size: int = 10,
        max_overflow: int = 20,
        pool_timeout: int = 30,
    ) -&gt; None:
        """Initialize TokenStorageService.
    
        Args:
            postgres_url: PostgreSQL connection URL
            pool_size: Number of connections to maintain in pool
            max_overflow: Maximum overflow connections
            pool_timeout: Timeout for getting connection from pool (seconds)
    
        Raises:
            StorageError: If database initialization fails
    
        Example:
            &gt;&gt;&gt; service = TokenStorageService(
            ...     "postgresql://user:pass@localhost/db",
            ...     pool_size=10,
            ... )
        """
        self.postgres_url = postgres_url
    
        try:
            # Create engine with connection pool
            self.engine = create_engine(
                postgres_url,
                poolclass=QueuePool,
                pool_size=pool_size,
                max_overflow=max_overflow,
                pool_timeout=pool_timeout,
                pool_pre_ping=True,  # Verify connections before use
                echo=False,
            )
    
            # Create session factory
            self.session_factory = sessionmaker(bind=self.engine)
    
            # Create tables (idempotent)
            Base.metadata.create_all(self.engine)
    
            logger.info(
                "TokenStorageService initialized",
                extra={
                    "pool_size": pool_size,
                    "max_overflow": max_overflow,
                },
            )
    
        except Exception as e:
&gt;           raise StorageError(
                f"Failed to initialize TokenStorageService: {e}",
                details={"error": str(e)},
            ) from e
E           lark_service.core.exceptions.StorageError: Failed to initialize TokenStorageService: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E           	Is the server running on that host and accepting TCP/IP connections?
E           connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E           	Is the server running on that host and accepting TCP/IP connections?
E           
E           (Background on this error at: https://sqlalche.me/e/20/e3q8)

src/lark_service/core/storage/postgres_storage.py:84: StorageError</error></testcase><testcase classname="tests.integration.test_token_lifecycle.TestTokenLifecycle" name="test_manual_refresh" time="0.017"><error message="failed on setup with &quot;lark_service.core.exceptions.StorageError: Failed to initialize TokenStorageService: (psycopg2.OperationalError) connection to server at &quot;localhost&quot; (::1), port 5432 failed: Connection refused&#10;&#09;Is the server running on that host and accepting TCP/IP connections?&#10;connection to server at &quot;localhost&quot; (127.0.0.1), port 5432 failed: Connection refused&#10;&#09;Is the server running on that host and accepting TCP/IP connections?&#10;&#10;(Background on this error at: https://sqlalche.me/e/20/e3q8)&quot;">self = &lt;sqlalchemy.engine.base.Connection object at 0x7fa853499ac0&gt;
engine = Engine(postgresql://lark:***@localhost:5432/lark_service)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
&gt;               self._dbapi_connection = engine.raw_connection()
                                         ^^^^^^^^^^^^^^^^^^^^^^^

/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lark_service user=lark password=lark_password_123 port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lark_service', 'host': 'localhost', 'password': 'lark_password_123', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
&gt;       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

self = &lt;lark_service.core.storage.postgres_storage.TokenStorageService object at 0x7fa8535c66f0&gt;
postgres_url = 'postgresql://lark:lark_password_123@localhost:5432/lark_service'
pool_size = 10, max_overflow = 20, pool_timeout = 30

    def __init__(
        self,
        postgres_url: str,
        pool_size: int = 10,
        max_overflow: int = 20,
        pool_timeout: int = 30,
    ) -&gt; None:
        """Initialize TokenStorageService.
    
        Args:
            postgres_url: PostgreSQL connection URL
            pool_size: Number of connections to maintain in pool
            max_overflow: Maximum overflow connections
            pool_timeout: Timeout for getting connection from pool (seconds)
    
        Raises:
            StorageError: If database initialization fails
    
        Example:
            &gt;&gt;&gt; service = TokenStorageService(
            ...     "postgresql://user:pass@localhost/db",
            ...     pool_size=10,
            ... )
        """
        self.postgres_url = postgres_url
    
        try:
            # Create engine with connection pool
            self.engine = create_engine(
                postgres_url,
                poolclass=QueuePool,
                pool_size=pool_size,
                max_overflow=max_overflow,
                pool_timeout=pool_timeout,
                pool_pre_ping=True,  # Verify connections before use
                echo=False,
            )
    
            # Create session factory
            self.session_factory = sessionmaker(bind=self.engine)
    
            # Create tables (idempotent)
&gt;           Base.metadata.create_all(self.engine)

src/lark_service/core/storage/postgres_storage.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5928: in create_all
    bind._run_ddl_visitor(
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3259: in _run_ddl_visitor
    with self.begin() as conn:
         ^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3249: in begin
    with self.connect() as conn:
         ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3285: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:145: in __init__
    Connection._handle_dbapi_exception_noconnection(
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2448: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lark_service user=lark password=lark_password_123 port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lark_service', 'host': 'localhost', 'password': 'lark_password_123', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
&gt;       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

test_config = Config(postgres_host='localhost', postgres_port=5432, postgres_db='lark_service', postgres_user='lark', postgres_passw...manual_refresh0/test_config.db'), log_level='INFO', max_retries=3, retry_backoff_base=0.1, token_refresh_threshold=0.5)

    @pytest.fixture
    def token_storage(test_config: Config) -&gt; TokenStorageService:
        """Create TokenStorageService for tests."""
&gt;       service = TokenStorageService(test_config.get_postgres_url())
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/integration/test_token_lifecycle.py:63: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;lark_service.core.storage.postgres_storage.TokenStorageService object at 0x7fa8535c66f0&gt;
postgres_url = 'postgresql://lark:lark_password_123@localhost:5432/lark_service'
pool_size = 10, max_overflow = 20, pool_timeout = 30

    def __init__(
        self,
        postgres_url: str,
        pool_size: int = 10,
        max_overflow: int = 20,
        pool_timeout: int = 30,
    ) -&gt; None:
        """Initialize TokenStorageService.
    
        Args:
            postgres_url: PostgreSQL connection URL
            pool_size: Number of connections to maintain in pool
            max_overflow: Maximum overflow connections
            pool_timeout: Timeout for getting connection from pool (seconds)
    
        Raises:
            StorageError: If database initialization fails
    
        Example:
            &gt;&gt;&gt; service = TokenStorageService(
            ...     "postgresql://user:pass@localhost/db",
            ...     pool_size=10,
            ... )
        """
        self.postgres_url = postgres_url
    
        try:
            # Create engine with connection pool
            self.engine = create_engine(
                postgres_url,
                poolclass=QueuePool,
                pool_size=pool_size,
                max_overflow=max_overflow,
                pool_timeout=pool_timeout,
                pool_pre_ping=True,  # Verify connections before use
                echo=False,
            )
    
            # Create session factory
            self.session_factory = sessionmaker(bind=self.engine)
    
            # Create tables (idempotent)
            Base.metadata.create_all(self.engine)
    
            logger.info(
                "TokenStorageService initialized",
                extra={
                    "pool_size": pool_size,
                    "max_overflow": max_overflow,
                },
            )
    
        except Exception as e:
&gt;           raise StorageError(
                f"Failed to initialize TokenStorageService: {e}",
                details={"error": str(e)},
            ) from e
E           lark_service.core.exceptions.StorageError: Failed to initialize TokenStorageService: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E           	Is the server running on that host and accepting TCP/IP connections?
E           connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E           	Is the server running on that host and accepting TCP/IP connections?
E           
E           (Background on this error at: https://sqlalche.me/e/20/e3q8)

src/lark_service/core/storage/postgres_storage.py:84: StorageError</error></testcase><testcase classname="tests.test_phase1_setup.TestProjectStructure" name="test_src_structure" time="0.001" /><testcase classname="tests.test_phase1_setup.TestProjectStructure" name="test_config_files" time="0.001" /><testcase classname="tests.test_phase1_setup.TestProjectStructure" name="test_docker_files" time="0.001" /><testcase classname="tests.test_phase1_setup.TestProjectStructure" name="test_migration_files" time="0.001" /><testcase classname="tests.test_phase1_setup.TestProjectStructure" name="test_documentation" time="0.001" /><testcase classname="tests.test_phase1_setup.TestPyprojectConfig" name="test_pyproject_exists" time="0.001" /><testcase classname="tests.test_phase1_setup.TestPyprojectConfig" name="test_ruff_config" time="0.001" /><testcase classname="tests.test_phase1_setup.TestPyprojectConfig" name="test_mypy_config" time="0.001" /><testcase classname="tests.test_phase1_setup.TestPyprojectConfig" name="test_pytest_config" time="0.001" /><testcase classname="tests.test_phase1_setup.TestRequirements" name="test_requirements_exists" time="0.001" /><testcase classname="tests.test_phase1_setup.TestEnvironmentVariables" name="test_env_example_exists" time="0.001" /><testcase classname="tests.test_phase1_setup.TestImports" name="test_import_lark_service" time="0.001" /><testcase classname="tests.test_phase1_setup.TestImports" name="test_import_core_modules" time="0.001" /><testcase classname="tests.test_phase1_setup.TestImports" name="test_import_business_modules" time="0.003" /><testcase classname="tests.test_phase1_setup.TestImports" name="test_import_utils" time="0.002" /><testcase classname="tests.unit.cli.test_app_commands.TestAppAdd" name="test_add_app_success" time="0.041" /><testcase classname="tests.unit.cli.test_app_commands.TestAppAdd" name="test_add_app_invalid_id" time="0.007" /><testcase classname="tests.unit.cli.test_app_commands.TestAppAdd" name="test_add_app_short_secret" time="0.007" /><testcase classname="tests.unit.cli.test_app_commands.TestAppList" name="test_list_empty" time="0.008" /><testcase classname="tests.unit.cli.test_app_commands.TestAppList" name="test_list_with_apps" time="0.029" /><testcase classname="tests.unit.cli.test_app_commands.TestAppList" name="test_list_json_format" time="0.020" /><testcase classname="tests.unit.cli.test_app_commands.TestAppShow" name="test_show_existing_app" time="0.021" /><testcase classname="tests.unit.cli.test_app_commands.TestAppShow" name="test_show_nonexistent_app" time="0.009" /><testcase classname="tests.unit.cli.test_app_commands.TestAppUpdate" name="test_update_app_name" time="0.031" /><testcase classname="tests.unit.cli.test_app_commands.TestAppDelete" name="test_delete_with_confirmation" time="0.021" /><testcase classname="tests.unit.cli.test_app_commands.TestAppDelete" name="test_delete_with_force" time="0.021" /><testcase classname="tests.unit.cli.test_app_commands.TestAppEnableDisable" name="test_disable_app" time="0.022" /><testcase classname="tests.unit.cli.test_app_commands.TestAppEnableDisable" name="test_enable_app" time="0.029" /><testcase classname="tests.unit.core.test_application_model.TestApplicationModel" name="test_application_creation" time="0.001" /><testcase classname="tests.unit.core.test_application_model.TestApplicationModel" name="test_is_active_status" time="0.001" /><testcase classname="tests.unit.core.test_application_model.TestApplicationModel" name="test_encrypt_decrypt_secret" time="0.001" /><testcase classname="tests.unit.core.test_application_model.TestApplicationModel" name="test_decrypt_with_wrong_key" time="0.001" /><testcase classname="tests.unit.core.test_application_model.TestApplicationModel" name="test_application_repr" time="0.001" /><testcase classname="tests.unit.core.test_application_model.TestApplicationModel" name="test_timestamps_auto_set" time="0.001" /><testcase classname="tests.unit.core.test_application_model.TestApplicationModel" name="test_permissions_field" time="0.001" /><testcase classname="tests.unit.core.test_application_model.TestApplicationModel" name="test_created_by_field" time="0.001" /><testcase classname="tests.unit.core.test_config.TestConfig" name="test_load_from_env_success" time="0.001" /><testcase classname="tests.unit.core.test_config.TestConfig" name="test_load_from_env_missing_required_var" time="0.003" /><testcase classname="tests.unit.core.test_config.TestConfig" name="test_load_from_env_invalid_encryption_key" time="0.003" /><testcase classname="tests.unit.core.test_config.TestConfig" name="test_load_from_env_invalid_threshold" time="0.003" /><testcase classname="tests.unit.core.test_config.TestConfig" name="test_get_postgres_url" time="0.001" /><testcase classname="tests.unit.core.test_config.TestConfig" name="test_get_rabbitmq_url" time="0.001" /><testcase classname="tests.unit.core.test_config.TestConfig" name="test_default_values" time="0.001" /><testcase classname="tests.unit.core.test_lock_manager.TestTokenRefreshLock" name="test_lock_initialization" time="0.001" /><testcase classname="tests.unit.core.test_lock_manager.TestTokenRefreshLock" name="test_acquire_and_release" time="0.002" /><testcase classname="tests.unit.core.test_lock_manager.TestTokenRefreshLock" name="test_concurrent_thread_access" time="1.002" /><testcase classname="tests.unit.core.test_lock_manager.TestTokenRefreshLock" name="test_timeout_behavior" time="0.503" /><testcase classname="tests.unit.core.test_lock_manager.TestTokenRefreshLock" name="test_non_blocking_acquire" time="0.002" /><testcase classname="tests.unit.core.test_lock_manager.TestTokenRefreshLock" name="test_multiple_app_ids" time="0.002" /><testcase classname="tests.unit.core.test_lock_manager.TestTokenRefreshLock" name="test_lock_file_creation" time="0.002" /><testcase classname="tests.unit.core.test_lock_manager.TestRefreshLockContext" name="test_context_manager_basic" time="0.503" /><testcase classname="tests.unit.core.test_lock_manager.TestRefreshLockContext" name="test_context_manager_with_exception" time="0.002" /><testcase classname="tests.unit.core.test_lock_manager.TestRefreshLockContext" name="test_context_manager_timeout" time="0.502" /><testcase classname="tests.unit.core.test_lock_manager.TestRefreshLockContext" name="test_nested_context_different_apps" time="1.004" /><testcase classname="tests.unit.core.test_retry.TestRetryStrategy" name="test_strategy_initialization" time="0.001" /><testcase classname="tests.unit.core.test_retry.TestRetryStrategy" name="test_calculate_delay_exponential_backoff" time="0.001" /><testcase classname="tests.unit.core.test_retry.TestRetryStrategy" name="test_calculate_delay_max_cap" time="0.001" /><testcase classname="tests.unit.core.test_retry.TestRetryStrategy" name="test_execute_success_first_try" time="0.001" /><testcase classname="tests.unit.core.test_retry.TestRetryStrategy" name="test_execute_success_after_retries" time="0.301" /><testcase classname="tests.unit.core.test_retry.TestRetryStrategy" name="test_execute_max_retries_exceeded" time="0.152" /><testcase classname="tests.unit.core.test_retry.TestRetryStrategy" name="test_execute_non_retryable_error" time="0.001" /><testcase classname="tests.unit.core.test_retry.TestRetryStrategy" name="test_execute_rate_limit_handling" time="0.201" /><testcase classname="tests.unit.core.test_retry.TestRetryStrategy" name="test_execute_rate_limit_with_custom_retry_after" time="0.151" /><testcase classname="tests.unit.core.test_retry.TestRetryStrategy" name="test_execute_multiple_rate_limits" time="0.202" /><testcase classname="tests.unit.core.test_retry.TestRetryStrategy" name="test_execute_rate_limit_max_retries" time="0.052" /><testcase classname="tests.unit.core.test_retry.TestRetryStrategy" name="test_execute_with_args_and_kwargs" time="0.001" /><testcase classname="tests.unit.core.test_retry.TestRetryDecorator" name="test_decorator_basic" time="0.051" /><testcase classname="tests.unit.core.test_retry.TestRetryDecorator" name="test_decorator_with_parameters" time="0.001" /><testcase classname="tests.unit.core.test_retry.TestRetryDecorator" name="test_decorator_preserves_exceptions" time="0.051" /><testcase classname="tests.unit.core.test_retry.TestRetryDecorator" name="test_decorator_custom_config" time="0.151" /><testcase classname="tests.unit.core.test_token_storage_model.TestTokenStorageModel" name="test_token_creation" time="0.002" /><testcase classname="tests.unit.core.test_token_storage_model.TestTokenStorageModel" name="test_is_expired_not_expired" time="0.001" /><testcase classname="tests.unit.core.test_token_storage_model.TestTokenStorageModel" name="test_is_expired_expired_token" time="0.001" /><testcase classname="tests.unit.core.test_token_storage_model.TestTokenStorageModel" name="test_is_expired_with_custom_now" time="0.001" /><testcase classname="tests.unit.core.test_token_storage_model.TestTokenStorageModel" name="test_should_refresh_not_needed" time="0.001" /><testcase classname="tests.unit.core.test_token_storage_model.TestTokenStorageModel" name="test_should_refresh_needed" time="0.001" /><testcase classname="tests.unit.core.test_token_storage_model.TestTokenStorageModel" name="test_should_refresh_expired_token" time="0.001" /><testcase classname="tests.unit.core.test_token_storage_model.TestTokenStorageModel" name="test_get_remaining_seconds_positive" time="0.001" /><testcase classname="tests.unit.core.test_token_storage_model.TestTokenStorageModel" name="test_get_remaining_seconds_negative" time="0.001" /><testcase classname="tests.unit.core.test_token_storage_model.TestTokenStorageModel" name="test_token_repr" time="0.001" /><testcase classname="tests.unit.core.test_token_storage_model.TestTokenStorageModel" name="test_different_token_types" time="0.001" /><testcase classname="tests.unit.utils.test_logger.TestLoggerSetup" name="test_setup_logger_default" time="0.001" /><testcase classname="tests.unit.utils.test_logger.TestLoggerSetup" name="test_setup_logger_with_level" time="0.001" /><testcase classname="tests.unit.utils.test_logger.TestLoggerSetup" name="test_setup_logger_with_file" time="0.002" /><testcase classname="tests.unit.utils.test_logger.TestLoggerSetup" name="test_setup_logger_json_format" time="0.001" /><testcase classname="tests.unit.utils.test_logger.TestLoggerSetup" name="test_get_logger" time="0.001" /><testcase classname="tests.unit.utils.test_logger.TestRequestContext" name="test_set_request_context" time="0.001" /><testcase classname="tests.unit.utils.test_logger.TestRequestContext" name="test_clear_request_context" time="0.001" /><testcase classname="tests.unit.utils.test_logger.TestRequestContext" name="test_context_manager" time="0.001" /><testcase classname="tests.unit.utils.test_logger.TestLogging" name="test_log_with_context" time="0.002" /><testcase classname="tests.unit.utils.test_logger.TestLogging" name="test_log_without_context" time="0.002" /><testcase classname="tests.unit.utils.test_logger.TestLogging" name="test_log_levels" time="0.002" /><testcase classname="tests.unit.utils.test_validators.TestAppCredentialsValidation" name="test_validate_app_id_success" time="0.001" /><testcase classname="tests.unit.utils.test_validators.TestAppCredentialsValidation" name="test_validate_app_id_empty" time="0.002" /><testcase classname="tests.unit.utils.test_validators.TestAppCredentialsValidation" name="test_validate_app_id_invalid_format" time="0.002" /><testcase classname="tests.unit.utils.test_validators.TestAppCredentialsValidation" name="test_validate_app_secret_success" time="0.001" /><testcase classname="tests.unit.utils.test_validators.TestAppCredentialsValidation" name="test_validate_app_secret_empty" time="0.002" /><testcase classname="tests.unit.utils.test_validators.TestAppCredentialsValidation" name="test_validate_app_secret_too_short" time="0.002" /><testcase classname="tests.unit.utils.test_validators.TestAppCredentialsValidation" name="test_validate_app_secret_too_long" time="0.001" /><testcase classname="tests.unit.utils.test_validators.TestUserIdentifierValidation" name="test_validate_open_id_success" time="0.001" /><testcase classname="tests.unit.utils.test_validators.TestUserIdentifierValidation" name="test_validate_open_id_invalid" time="0.002" /><testcase classname="tests.unit.utils.test_validators.TestUserIdentifierValidation" name="test_validate_user_id_success" time="0.001" /><testcase classname="tests.unit.utils.test_validators.TestUserIdentifierValidation" name="test_validate_user_id_invalid" time="0.002" /><testcase classname="tests.unit.utils.test_validators.TestUserIdentifierValidation" name="test_validate_union_id_success" time="0.001" /><testcase classname="tests.unit.utils.test_validators.TestUserIdentifierValidation" name="test_validate_union_id_invalid" time="0.002" /><testcase classname="tests.unit.utils.test_validators.TestUserIdentifierValidation" name="test_validate_chat_id_success" time="0.001" /><testcase classname="tests.unit.utils.test_validators.TestUserIdentifierValidation" name="test_validate_chat_id_invalid" time="0.002" /><testcase classname="tests.unit.utils.test_validators.TestTokenValidation" name="test_validate_token_success" time="0.001" /><testcase classname="tests.unit.utils.test_validators.TestTokenValidation" name="test_validate_token_empty" time="0.002" /><testcase classname="tests.unit.utils.test_validators.TestTokenValidation" name="test_validate_token_too_short" time="0.001" /><testcase classname="tests.unit.utils.test_validators.TestTokenValidation" name="test_validate_token_too_long" time="0.001" /><testcase classname="tests.unit.utils.test_validators.TestUrlValidation" name="test_validate_url_https_success" time="0.001" /><testcase classname="tests.unit.utils.test_validators.TestUrlValidation" name="test_validate_url_http_with_flag" time="0.001" /><testcase classname="tests.unit.utils.test_validators.TestUrlValidation" name="test_validate_url_http_require_https" time="0.002" /><testcase classname="tests.unit.utils.test_validators.TestUrlValidation" name="test_validate_url_empty" time="0.001" /><testcase classname="tests.unit.utils.test_validators.TestUrlValidation" name="test_validate_url_missing_protocol" time="0.001" /><testcase classname="tests.unit.utils.test_validators.TestUrlValidation" name="test_validate_url_missing_domain" time="0.001" /><testcase classname="tests.unit.utils.test_validators.TestFilePathValidation" name="test_validate_file_path_success" time="0.001" /><testcase classname="tests.unit.utils.test_validators.TestFilePathValidation" name="test_validate_file_path_not_exist" time="0.002" /><testcase classname="tests.unit.utils.test_validators.TestFilePathValidation" name="test_validate_file_path_no_exist_check" time="0.001" /><testcase classname="tests.unit.utils.test_validators.TestNumericValidation" name="test_validate_positive_int_success" time="0.001" /><testcase classname="tests.unit.utils.test_validators.TestNumericValidation" name="test_validate_positive_int_zero" time="0.001" /><testcase classname="tests.unit.utils.test_validators.TestNumericValidation" name="test_validate_positive_int_negative" time="0.001" /><testcase classname="tests.unit.utils.test_validators.TestNumericValidation" name="test_validate_positive_int_invalid_type" time="0.001" /><testcase classname="tests.unit.utils.test_validators.TestNumericValidation" name="test_validate_non_negative_float_success" time="0.001" /><testcase classname="tests.unit.utils.test_validators.TestNumericValidation" name="test_validate_non_negative_float_negative" time="0.001" /><testcase classname="tests.unit.utils.test_validators.TestNumericValidation" name="test_validate_non_negative_float_invalid_type" time="0.001" /><testcase classname="tests.unit.utils.test_validators.TestEnumValidation" name="test_validate_enum_success" time="0.001" /><testcase classname="tests.unit.utils.test_validators.TestEnumValidation" name="test_validate_enum_invalid" time="0.002" /></testsuite></testsuites>